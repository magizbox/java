{
    "docs": [
        {
            "location": "/", 
            "text": "Java\n\n\nJava is a general-purpose computer programming language that is concurrent, class-based, object-oriented, and specifically designed to have as few implementation dependencies as possible. It is intended to let application developers \"write once, run anywhere\" (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation. Java applications are typically compiled to bytecode that can run on any Java virtual machine (JVM) regardless of computer architecture. As of 2016, Java is one of the most popular programming languages in use, particularly for client-server web applications, with a reported 9 million developers. Java was originally developed by \nJames Gosling\n at Sun Microsystems (which has since been acquired by Oracle Corporation) and released in 1995 as a core component of Sun Microsystems' Java platform. The language derives much of its syntax from C and C++, but it has fewer low-level facilities than either of them.\n\n\nThe original and reference implementation Java compilers, virtual machines, and class libraries were originally released by Sun under proprietary licences. As of May 2007, in compliance with the specifications of the Java Community Process, Sun relicensed most of its Java technologies under the GNU General Public License. Others have also developed alternative implementations of these Sun technologies, such as the GNU Compiler for Java (bytecode compiler), GNU Classpath (standard libraries), and IcedTea-Web (browser plugin for applets).\n\n\nBooks\n\n\n\n\n\n\n\n\nCourses", 
            "title": "<span class='fa fa-home'></span> Home"
        }, 
        {
            "location": "/#java", 
            "text": "Java is a general-purpose computer programming language that is concurrent, class-based, object-oriented, and specifically designed to have as few implementation dependencies as possible. It is intended to let application developers \"write once, run anywhere\" (WORA), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation. Java applications are typically compiled to bytecode that can run on any Java virtual machine (JVM) regardless of computer architecture. As of 2016, Java is one of the most popular programming languages in use, particularly for client-server web applications, with a reported 9 million developers. Java was originally developed by  James Gosling  at Sun Microsystems (which has since been acquired by Oracle Corporation) and released in 1995 as a core component of Sun Microsystems' Java platform. The language derives much of its syntax from C and C++, but it has fewer low-level facilities than either of them.  The original and reference implementation Java compilers, virtual machines, and class libraries were originally released by Sun under proprietary licences. As of May 2007, in compliance with the specifications of the Java Community Process, Sun relicensed most of its Java technologies under the GNU General Public License. Others have also developed alternative implementations of these Sun technologies, such as the GNU Compiler for Java (bytecode compiler), GNU Classpath (standard libraries), and IcedTea-Web (browser plugin for applets).", 
            "title": "Java"
        }, 
        {
            "location": "/#books", 
            "text": "", 
            "title": "Books"
        }, 
        {
            "location": "/#courses", 
            "text": "", 
            "title": "Courses"
        }, 
        {
            "location": "/getting_started/", 
            "text": "Installation\n\n\nUbuntu\n\n\nStep 1. Download sdk\n\n\nhttp://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html\n\n\n\n\nStep 2. Create folder jvm\n\n\nsudo mkdir /usr/lib/jvm/\n\n\n\n\nStep 3. cd to folder downloads jdk and run command\n\n\nsudo mv jdk1.7.0_x/ /usr/lib/jvm/jdk1.7.0_x\n\n\n\n\nRun install java\n\n\nsudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.7.0_x/jre/bin/java 0\n\n\n\n\nAdd path jdk : /usr/lib/jvm/jdk1.7.0_x\n\n\nsu -\nnano /etc/environment", 
            "title": "<span class='fa fa-cloud-download'></span> Getting Started"
        }, 
        {
            "location": "/getting_started/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/getting_started/#ubuntu", 
            "text": "Step 1. Download sdk  http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html  Step 2. Create folder jvm  sudo mkdir /usr/lib/jvm/  Step 3. cd to folder downloads jdk and run command  sudo mv jdk1.7.0_x/ /usr/lib/jvm/jdk1.7.0_x", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/getting_started/#run-install-java", 
            "text": "sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.7.0_x/jre/bin/java 0  Add path jdk : /usr/lib/jvm/jdk1.7.0_x  su -\nnano /etc/environment", 
            "title": "Run install java"
        }, 
        {
            "location": "/introduction/", 
            "text": "Java\n\n\nI can code Java, but... \n1\n\n\n\n\nBest Programming languages \n2\n\n\n\n\nInstallation \n3\n\n\n\n# cent os 6.5\nyum install java-1.7.0-openjdk-devel\n\n\n\n\nConcepts\n\n\n\nAnnotations\n\n\nTools\n\n\n\n\n\n\n\n\n\n\nBuild Tool\n\n\n\nTest\n\n\n\n\n\n\nGradle\n\n\nJUnit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPatterns in Real Life\n\n\n\n\n\n\n\nFunny Story | Best Programming languages\n\n\n\n\n\n\n\nHow To Install Java on CentOS and Fedora\n\n\n\n\n\n\n\n\n\n\n2. Hello World \n1\n\n\npublic class HelloWorld {\n\n    public static void main(String[] args) {\n        // Prints \nHello, World\n to the terminal window.\n        System.out.println(\nHello, World\n);\n    }\n\n}\n\n\n\n\nJava: Parallel\n\n\nThread\n\n\nTimer\n\n\nJava: Configuration\n\n\n-VM options : VM options are loaded from the IDE_HOME\\bin\\\n[bits][.exe].vmoptions file.\n[1]\n\n-ea : enable assertions\n\n\n-ea -D[FILE_NAME]=\n$PATH_DATA\n\n\n\n\n\nJava: Web with Spring\n\n\n\n\n\n  \nSpring helps development teams everywhere build simple, portable, fast and flexible JVM-based systems and applications.\n\n\n\n\n\nComponents\n\n\n\nSpring Boot\n: Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can \"just run\". We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.\n\n\n\nSpring: Database\n\n\nDatabase Migration\n\n\nFlyway\n\n\nJava: Errors\n\n\nTwo Many Open Files \n1\n \n2\n\n\nEdit  \n/etc/sysctl.conf\n\n\nfs.file-max = 100000\n\n\n\n\nSpring, http://www.tomcatexpert.com/blog/2010/04/01/configuring-jdbc-pool-high-concurrency\n\n\n\n\n\n\n\n\n\n\nLinux Increase The Maximum Number Of Open Files / File Descriptors (FD)\n\n\n\n\n\n\n[java 1=\"Too\" 2=\"many\" 3=\"open\" 4=\"files\" 5=\"Spring\" 6=\"Hibernate\" 7=\"Tomcat\" language=\".net.SocketException:\"]\n/java", 
            "title": "Introduction"
        }, 
        {
            "location": "/introduction/#java", 
            "text": "I can code Java, but...  1   Best Programming languages  2", 
            "title": "Java"
        }, 
        {
            "location": "/introduction/#2-hello-world-1", 
            "text": "public class HelloWorld {\n\n    public static void main(String[] args) {\n        // Prints  Hello, World  to the terminal window.\n        System.out.println( Hello, World );\n    }\n\n}", 
            "title": "2. Hello World 1"
        }, 
        {
            "location": "/introduction/#java-parallel", 
            "text": "Thread", 
            "title": "Java: Parallel"
        }, 
        {
            "location": "/introduction/#timer", 
            "text": "", 
            "title": "Timer"
        }, 
        {
            "location": "/introduction/#java-configuration", 
            "text": "-VM options : VM options are loaded from the IDE_HOME\\bin\\ [bits][.exe].vmoptions file. [1] \n-ea : enable assertions  -ea -D[FILE_NAME]= $PATH_DATA", 
            "title": "Java: Configuration"
        }, 
        {
            "location": "/introduction/#java-web-with-spring", 
            "text": "Spring helps development teams everywhere build simple, portable, fast and flexible JVM-based systems and applications.", 
            "title": "Java: Web with Spring"
        }, 
        {
            "location": "/introduction/#spring-database", 
            "text": "", 
            "title": "Spring: Database"
        }, 
        {
            "location": "/introduction/#database-migration", 
            "text": "Flyway", 
            "title": "Database Migration"
        }, 
        {
            "location": "/introduction/#java-errors", 
            "text": "", 
            "title": "Java: Errors"
        }, 
        {
            "location": "/introduction/#two-many-open-files-1-2", 
            "text": "Edit   /etc/sysctl.conf  fs.file-max = 100000  Spring, http://www.tomcatexpert.com/blog/2010/04/01/configuring-jdbc-pool-high-concurrency      Linux Increase The Maximum Number Of Open Files / File Descriptors (FD)    [java 1=\"Too\" 2=\"many\" 3=\"open\" 4=\"files\" 5=\"Spring\" 6=\"Hibernate\" 7=\"Tomcat\" language=\".net.SocketException:\"] /java", 
            "title": "Two Many Open Files 1 2"
        }, 
        {
            "location": "/basic_syntax/", 
            "text": "Variable \n Types\n\n\nAlthough Java is object oriented, not all types are objects. It is built on top of basic variable types called primitives.\n\n\nHere is a list of all primitives in Java:\n\n\n\n\nbyte\n (number, 1 byte)\n\n\nshort\n (number, 2 bytes)\n\n\nint\n (number, 4 bytes)\n\n\nlong\n (number, 8 bytes)\n\n\nfloat\n (float number, 4 bytes)\n\n\ndouble\n (float number, 8 bytes)\n\n\nchar\n (a character, 2 bytes)\n\n\nboolean\n (true or false, 1 byte)\nJava is a strong typed language, which means variables need to be defined before we use them.\n\n\n\n\nNumbers\n\n\nTo declare and assign a number use the following syntax:\n\n\nint myNumber;\nmyNumber = 5;\n\n\n\n\nOr you can combine them:\n\n\nint myNumber = 5;\n\n\n\n\nTo define a double floating point number, use the following syntax:\n\n\ndouble d = 4.5;\nd = 3.0;\n\n\n\n\nIf you want to use float, you will have to cast:\n\n\nfloat f = (float) 4.5;\n\n\n\n\nOr, You can use this:\n\n\nfloat f = 4.5f (f is a shorter way of casting float)\n\n\n\n\nCharacters and Strings\n\n\nIn Java, a character is it's own type and it's not simply a number, so it's not common to put an ascii value in it, there is a special syntax for chars:\n\n\nchar c = 'g';\n\n\n\n\nString is not a primitive. It's a real type, but Java has special treatment for String.\n\n\nHere are some ways to use a string:\n\n\n// Create a string with a constructor\nString s1 = new String(\nWho let the dogs out?\n);\n// Just using \n creates a string, so no need to write it the previous way.\nString s2 = \nWho who who who!\n;\n// Java defined the operator + on strings to concatenate:\nString s3 = s1 + s2;\n\n\n\n\nThere is no operator overloading in Java! The operator + is only defined for strings, you will never see it with other objects, only primitives.\n\n\nYou can also concat string to primitives:\n\n\nint num = 5;\nString s = \nI have \n + num + \n cookies\n; //Be sure not to use \n with primitives.\n\n\n\n\nboolean\n\n\nEvery comparison operator in java will return the type \nboolean\n that not like other languages can only accept two special values: \ntrue\n or \nfalse\n.\n\n\nboolean b = false;\nb = true;\n\nboolean toBe = false;\nb = toBe || !toBe;\nif (b) {\n    System.out.println(toBe);\n}\n\nint children = 0;\nb = children; // Will not work\nif (children) { // Will not work\n    // Will not work\n}\n\n\n\n\nOperators\n\n\nJava provides a rich set of operators to manipulate variables. We can divide all the Java operators into the following groups:\n\n\n\n\nArithmetic Operators\n\n\nRelational Operators\n\n\nBitwise Operators\n\n\nLogical Operators\n\n\nAssignment Operators\n\n\nMisc Operators\n\n\n\n\nThe Arithmetic Operators\n\n\nArithmetic operators are used in mathematical expressions in the same way that they are used in algebra.\n\n\nThe following table lists the arithmetic operators:\n\n\n\n  \n\n  \n\n    \nOperator\n\n    \nDescription\n\n    \nExample\n\n  \n\n  \n\n    \n+ (Addition)\n\n    \nAdds values on either side of the operator\n\n    \n10 + 20 -\n 30\n\n  \n\n  \n\n    \n- (Subtraction)\n\n    \nSubtracts right hand operand from left hand operand\n\n    \n10 - 20\n-\n -10\n\n  \n\n  \n\n    \n* ( Multiplication )\n\n    \nMultiplies values on either side of the operator\n\n    \n10 *\n20\n-\n 200\n\n  \n\n  \n\n    \n/ (Division)\n\n    \nDivides left hand operand by right hand operand\n\n    \n20 / 10 -\n 2\n\n  \n\n  \n\n    \n% (Modulus)\n\n    \nDivides left hand operand by right hand operand and returns remainder\n\n    \n7\n% 3 -\n1\n\n  \n\n  \n\n    \n++ (Increment)\n\n    \nIncreases the value of operand by 1\n\n    \n\n      \na = 20\n\n\n      \na++ -\n 21\n\n    \n\n  \n\n  \n\n    \n-- ( Decrement )\n\n    \nDecreases the value of operand by 1\n\n    \n\n      \na = 20\n\n\n      \na-- -\n 19\n\n    \n\n  \n\n  \n\n\n\n\n\nThe Relational Operators\n\n\nThere are following relational operators supported by Java language\n\n\n== (equal to)\nChecks if the values of two operands are equal or not, if yes then condition becomes true.\n\n\nExample: (A == B) is not true.\n2   != (not equal to)\nChecks if the values of two operands are equal or not, if values are not equal then condition becomes true.\n\n\nExample: (A != B) is true.\n\n\n3   \n (greater than)\nChecks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.\n\n\nExample: (A \n B) is not true.\n4   \n (less than)\nChecks if the value of left operand is less than the value of right operand, if yes then condition becomes true.\n\n\nExample: (A \n B) is true.\n5   \n= (greater than or equal to)\nChecks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.\n\n\nExample (A \n= B) is not true.\n6   \n= (less than or equal to)\nChecks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.\n\n\nexample(A \n= B) is true.\n\n\nThe Bitwise Operators\n\n\nJava defines several bitwise operators, which can be applied to the integer types, long, int, short, char, and byte.\n\n\nBitwise operator works on bits and performs bit-by-bit operation. Assume if a = 60; and b = 13; now in binary format they will be as follows:\n\n\na = 0011 1100\n\n\nb = 0000 1101\n\n\n\n\na\nb = 0000 1100\n\n\na|b = 0011 1101\n\n\na^b = 0011 0001\n\n\n~a  = 1100 0011\n\n\nThe following table lists the bitwise operators:\n\n\nAssume integer variable A holds 60 and variable B holds 13 then:\n\n\n (bitwise and)\nBinary AND Operator copies a bit to the result if it exists in both operands.\n\n\nExample: (A \n B) will give 12 which is 0000 1100\n2   | (bitwise or)\nBinary OR Operator copies a bit if it exists in either operand.\n\n\nExample: (A | B) will give 61 which is 0011 1101\n3   ^ (bitwise XOR)\nBinary XOR Operator copies the bit if it is set in one operand but not both.\n\n\nExample: (A ^ B) will give 49 which is 0011 0001\n4   ~ (bitwise compliment)\nBinary Ones Complement Operator is unary and has the effect of 'flipping' bits.\n\n\nExample: (~A ) will give -61 which is 1100 0011 in 2's complement form due to a signed binary number.\n5   \n (left shift)\nBinary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand\n\n\nExample: A \n 2 will give 240 which is 1111 0000\n6   \n (right shift)\nBinary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.\n\n\nExample: A \n 2 will give 15 which is 1111\n7   \n (zero fill right shift)\nShift right zero fill operator. The left operands value is moved right by the number of bits specified by the right operand and shifted values are filled up with zeros.\n\n\nExample: A \n2 will give 15 which is 0000 1111\n\n\nThe Logical Operators\n\n\nThe following table lists the logical operators:\n\n\nAssume Boolean variables A holds true and variable B holds false, then:\n\n\n (logical and)\nCalled Logical AND operator. If both the operands are non-zero, then the condition becomes true.\n\n\nExample (A \n B) is false.\n2   || (logical or)\nCalled Logical OR Operator. If any of the two operands are non-zero, then the condition becomes true.\n\n\nExample (A || B) is true.\n3   ! (logical not)\nCalled Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.\n\n\nExample !(A \n B) is true.\n\n\nThe Assignment Operators\n\n\nThere are following assignment operators supported by Java language:\n\n\nShow Examples\n\n\nSR.NO   Operator and Description\n1   =\nSimple assignment operator, Assigns values from right side operands to left side operand.\n\n\nExample: C = A + B will assign value of A + B into C\n2   +=\nAdd AND assignment operator, It adds right operand to the left operand and assign the result to left operand.\n\n\nExample: C += A is equivalent to C = C + A\n3   -=\nSubtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand.\n\n\nExample:C -= A is equivalent to C = C - A\n4   *=\nMultiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand.\n\n\nExample: C *= A is equivalent to C = C * A\n5   /=\nDivide AND assignment operator, It divides left operand with the right operand and assign the result to left operand\n\n\nExampleC /= A is equivalent to C = C / A\n6   %=\nModulus AND assignment operator, It takes modulus using two operands and assign the result to left operand.\n\n\nExample: C %= A is equivalent to C = C % A\n7   \n=\nLeft shift AND assignment operator.\n\n\nExampleC \n= 2 is same as C = C \n 2\n8   \n=\nRight shift AND assignment operator\n\n\nExample C \n= 2 is same as C = C \n 2\n9   \n=\nBitwise AND assignment operator.\n\n\nExample: C \n= 2 is same as C = C \n 2\n10  ^=\nbitwise exclusive OR and assignment operator.\n\n\nExample: C ^= 2 is same as C = C ^ 2\n11  |=\nbitwise inclusive OR and assignment operator.\n\n\nExample: C |= 2 is same as C = C | 2\n\n\nMiscellaneous Operators\n\n\nThere are few other operators supported by Java Language.\n\n\nConditional Operator ( ? : )\nConditional operator is also known as the ternary operator. This operator consists of three operands and is used to evaluate Boolean expressions. The goal of the operator is to decide which value should be assigned to the variable. The operator is written as:\n\n\nvariable x = (expression) ? value if true : value if false\n\n\n\n\nFollowing is the example:\n\n\npublic class Test {\n\n   public static void main(String args[]){\n      int a, b;\n      a = 10;\n      b = (a == 1) ? 20: 30;\n      System.out.println( \nValue of b is : \n +  b );\n\n      b = (a == 10) ? 20: 30;\n      System.out.println( \nValue of b is : \n + b );\n   }\n}\n\n\n\n\nThis would produce the following result ?\n\n\nValue of b is : 30\nValue of b is : 20\n\n\n\n\nPrecedence of Operators\n\n\nOperator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator:\n\n\nFor example, x = 7 + 3 * 2; here x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.\n\n\nHere, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.\n\n\nCategory    Operator    Associativity \nPostfix     () [] . (dot operator)  Left toright \nUnary   ++ - - ! ~  Right to left \nMultiplicative      * / %   Left to right \nAdditive    + -     Left to right \nShift   \n \n \n   Left to right \nRelational      \n \n= \n \n=   Left to right \nEquality    == !=   Left to right \nBitwise AND     \n   Left to right \nBitwise XOR     ^   Left to right \nBitwise OR  |   Left to right \nLogical AND     \n  Left to right \nLogical OR  ||  Left to right \nConditional     ?:  Right to left \nAssignment  = += -= *= /= %= \n= \n= \n= ^= |=   Right to left \n\n\nConditional\n\n\nJava uses boolean variables to evaluate conditions. The boolean values \ntrue\n and \nfalse\n are returned when an expression is compared or evaluated. For example:\n\n\nint a = 4;\nboolean b = a == 4;\n\nif (b) {\n    System.out.println(\nIt's true!\n);\n}\n\n\n\n\nOf course we don't normally assign a conditional expression to a boolean, we just use the short version:\n\n\nint a = 4;\n\nif (a == 4) {\n    System.out.println(\nOhhh! So a is 4!\n);\n}\n\n\n\n\nBoolean operators\n\n\nThere aren't that many operators to use in conditional statements and most of them are pretty strait forward:\n\n\nint a = 4;\nint b = 5;\nboolean result;\nresult = a \n b; // true\nresult = a \n b; // false\nresult = a \n= 4 // a smaller or equal to 4 - true\nresult = b \n= 6 // b bigger or equal to 6 - false\nresult = a == b // a equal to b - false\nresult = a != b // a is not equal to b - true\nresult = a \n b || a \n b // Logical or - true\nresult = 3 \n a \n a \n 6 // Logical and - true\nresult = !result // Logical not - false\n\n\n\n\nif - else and between\n\n\nThe if, else statement in java is pretty simple.\n\n\nif (a == b) {\n    // a and b are equal, let's do something cool\n}\n\n\n\n\nAnd we can also add an else statement after an if, to do something if the condition is not true\n\n\nif (a == b) {\n    // We already know this part\n} else {\n    // a and b are not equal... :/\n}\n\n\n\n\nThe if - else statements doesn't have to be in several lines with {}, if can be used in one line, or without the {}, for a single line statment.\n\n\nif (a == b)\n    System.out.println(\nAnother line Wow!\n);\nelse\n    System.out.println(\nDouble rainbow!\n);\n\n\n\n\nAlthough this method might be useful for making your code shorter by using fewer lines, we strongly recommend for beginners not to use this short version of statements and always use the full version with {}. This goes to every statement that can be shorted to a single line (for, while, etc).\n\n\nThe ugly side of if\n\n\nThere is a another way to write a one line if - else statement by using the operator ? :\n\n\nint a = 4;\nint result = a == 4 ? 1 : 8;\n\n// result will be 1\n// This is equivalent to\nint result;\n\nif (a == 4) {\n    result = 1;\n} else {\n    result = 8;\n}\n\n\n\n\nAgain, we strongly recommend for beginners not to use this version of if.\n\n\n== and equals\n\n\nThe operator == works a bit different on objects than on primitives. When we are using objects and want to check if they are equal, the operator == will say if they are the same, if you want to check if they are logically equal, you should use the equals method on the object. For example:\n\n\nString a = new String(\nWow\n);\nString b = new String(\nWow\n);\nString sameA = a;\n\nboolean r1 = a == b;      // This is false, since a and b are not the same object\nboolean r2 = a.equals(b); // This is true, since a and b are logically equals\nboolean r3 = a == sameA;  // This is true, since a and sameA are really the same object", 
            "title": "Basic Syntax"
        }, 
        {
            "location": "/basic_syntax/#variable-types", 
            "text": "Although Java is object oriented, not all types are objects. It is built on top of basic variable types called primitives.  Here is a list of all primitives in Java:   byte  (number, 1 byte)  short  (number, 2 bytes)  int  (number, 4 bytes)  long  (number, 8 bytes)  float  (float number, 4 bytes)  double  (float number, 8 bytes)  char  (a character, 2 bytes)  boolean  (true or false, 1 byte)\nJava is a strong typed language, which means variables need to be defined before we use them.", 
            "title": "Variable &amp; Types"
        }, 
        {
            "location": "/basic_syntax/#numbers", 
            "text": "To declare and assign a number use the following syntax:  int myNumber;\nmyNumber = 5;  Or you can combine them:  int myNumber = 5;  To define a double floating point number, use the following syntax:  double d = 4.5;\nd = 3.0;  If you want to use float, you will have to cast:  float f = (float) 4.5;  Or, You can use this:  float f = 4.5f (f is a shorter way of casting float)", 
            "title": "Numbers"
        }, 
        {
            "location": "/basic_syntax/#characters-and-strings", 
            "text": "In Java, a character is it's own type and it's not simply a number, so it's not common to put an ascii value in it, there is a special syntax for chars:  char c = 'g';  String is not a primitive. It's a real type, but Java has special treatment for String.  Here are some ways to use a string:  // Create a string with a constructor\nString s1 = new String( Who let the dogs out? );\n// Just using   creates a string, so no need to write it the previous way.\nString s2 =  Who who who who! ;\n// Java defined the operator + on strings to concatenate:\nString s3 = s1 + s2;  There is no operator overloading in Java! The operator + is only defined for strings, you will never see it with other objects, only primitives.  You can also concat string to primitives:  int num = 5;\nString s =  I have   + num +   cookies ; //Be sure not to use   with primitives.", 
            "title": "Characters and Strings"
        }, 
        {
            "location": "/basic_syntax/#boolean", 
            "text": "Every comparison operator in java will return the type  boolean  that not like other languages can only accept two special values:  true  or  false .  boolean b = false;\nb = true;\n\nboolean toBe = false;\nb = toBe || !toBe;\nif (b) {\n    System.out.println(toBe);\n}\n\nint children = 0;\nb = children; // Will not work\nif (children) { // Will not work\n    // Will not work\n}", 
            "title": "boolean"
        }, 
        {
            "location": "/basic_syntax/#operators", 
            "text": "Java provides a rich set of operators to manipulate variables. We can divide all the Java operators into the following groups:   Arithmetic Operators  Relational Operators  Bitwise Operators  Logical Operators  Assignment Operators  Misc Operators", 
            "title": "Operators"
        }, 
        {
            "location": "/basic_syntax/#the-arithmetic-operators", 
            "text": "Arithmetic operators are used in mathematical expressions in the same way that they are used in algebra.  The following table lists the arithmetic operators:  \n   \n   \n     Operator \n     Description \n     Example \n   \n   \n     + (Addition) \n     Adds values on either side of the operator \n     10 + 20 -  30 \n   \n   \n     - (Subtraction) \n     Subtracts right hand operand from left hand operand \n     10 - 20 -  -10 \n   \n   \n     * ( Multiplication ) \n     Multiplies values on either side of the operator \n     10 * 20 -  200 \n   \n   \n     / (Division) \n     Divides left hand operand by right hand operand \n     20 / 10 -  2 \n   \n   \n     % (Modulus) \n     Divides left hand operand by right hand operand and returns remainder \n     7 % 3 - 1 \n   \n   \n     ++ (Increment) \n     Increases the value of operand by 1 \n     \n       a = 20 \n\n       a++ -  21 \n     \n   \n   \n     -- ( Decrement ) \n     Decreases the value of operand by 1 \n     \n       a = 20 \n\n       a-- -  19", 
            "title": "The Arithmetic Operators"
        }, 
        {
            "location": "/basic_syntax/#the-relational-operators", 
            "text": "There are following relational operators supported by Java language  == (equal to)\nChecks if the values of two operands are equal or not, if yes then condition becomes true.  Example: (A == B) is not true.\n2   != (not equal to)\nChecks if the values of two operands are equal or not, if values are not equal then condition becomes true.  Example: (A != B) is true.  3     (greater than)\nChecks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.  Example: (A   B) is not true.\n4     (less than)\nChecks if the value of left operand is less than the value of right operand, if yes then condition becomes true.  Example: (A   B) is true.\n5    = (greater than or equal to)\nChecks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.  Example (A  = B) is not true.\n6    = (less than or equal to)\nChecks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.  example(A  = B) is true.", 
            "title": "The Relational Operators"
        }, 
        {
            "location": "/basic_syntax/#the-bitwise-operators", 
            "text": "Java defines several bitwise operators, which can be applied to the integer types, long, int, short, char, and byte.  Bitwise operator works on bits and performs bit-by-bit operation. Assume if a = 60; and b = 13; now in binary format they will be as follows:  a = 0011 1100  b = 0000 1101   a b = 0000 1100  a|b = 0011 1101  a^b = 0011 0001  ~a  = 1100 0011  The following table lists the bitwise operators:  Assume integer variable A holds 60 and variable B holds 13 then:   (bitwise and)\nBinary AND Operator copies a bit to the result if it exists in both operands.  Example: (A   B) will give 12 which is 0000 1100\n2   | (bitwise or)\nBinary OR Operator copies a bit if it exists in either operand.  Example: (A | B) will give 61 which is 0011 1101\n3   ^ (bitwise XOR)\nBinary XOR Operator copies the bit if it is set in one operand but not both.  Example: (A ^ B) will give 49 which is 0011 0001\n4   ~ (bitwise compliment)\nBinary Ones Complement Operator is unary and has the effect of 'flipping' bits.  Example: (~A ) will give -61 which is 1100 0011 in 2's complement form due to a signed binary number.\n5     (left shift)\nBinary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand  Example: A   2 will give 240 which is 1111 0000\n6     (right shift)\nBinary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.  Example: A   2 will give 15 which is 1111\n7     (zero fill right shift)\nShift right zero fill operator. The left operands value is moved right by the number of bits specified by the right operand and shifted values are filled up with zeros.  Example: A  2 will give 15 which is 0000 1111", 
            "title": "The Bitwise Operators"
        }, 
        {
            "location": "/basic_syntax/#the-logical-operators", 
            "text": "The following table lists the logical operators:  Assume Boolean variables A holds true and variable B holds false, then:   (logical and)\nCalled Logical AND operator. If both the operands are non-zero, then the condition becomes true.  Example (A   B) is false.\n2   || (logical or)\nCalled Logical OR Operator. If any of the two operands are non-zero, then the condition becomes true.  Example (A || B) is true.\n3   ! (logical not)\nCalled Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true then Logical NOT operator will make false.  Example !(A   B) is true.", 
            "title": "The Logical Operators"
        }, 
        {
            "location": "/basic_syntax/#the-assignment-operators", 
            "text": "There are following assignment operators supported by Java language:  Show Examples  SR.NO   Operator and Description\n1   =\nSimple assignment operator, Assigns values from right side operands to left side operand.  Example: C = A + B will assign value of A + B into C\n2   +=\nAdd AND assignment operator, It adds right operand to the left operand and assign the result to left operand.  Example: C += A is equivalent to C = C + A\n3   -=\nSubtract AND assignment operator, It subtracts right operand from the left operand and assign the result to left operand.  Example:C -= A is equivalent to C = C - A\n4   *=\nMultiply AND assignment operator, It multiplies right operand with the left operand and assign the result to left operand.  Example: C *= A is equivalent to C = C * A\n5   /=\nDivide AND assignment operator, It divides left operand with the right operand and assign the result to left operand  ExampleC /= A is equivalent to C = C / A\n6   %=\nModulus AND assignment operator, It takes modulus using two operands and assign the result to left operand.  Example: C %= A is equivalent to C = C % A\n7    =\nLeft shift AND assignment operator.  ExampleC  = 2 is same as C = C   2\n8    =\nRight shift AND assignment operator  Example C  = 2 is same as C = C   2\n9    =\nBitwise AND assignment operator.  Example: C  = 2 is same as C = C   2\n10  ^=\nbitwise exclusive OR and assignment operator.  Example: C ^= 2 is same as C = C ^ 2\n11  |=\nbitwise inclusive OR and assignment operator.  Example: C |= 2 is same as C = C | 2", 
            "title": "The Assignment Operators"
        }, 
        {
            "location": "/basic_syntax/#miscellaneous-operators", 
            "text": "There are few other operators supported by Java Language.  Conditional Operator ( ? : )\nConditional operator is also known as the ternary operator. This operator consists of three operands and is used to evaluate Boolean expressions. The goal of the operator is to decide which value should be assigned to the variable. The operator is written as:  variable x = (expression) ? value if true : value if false  Following is the example:  public class Test {\n\n   public static void main(String args[]){\n      int a, b;\n      a = 10;\n      b = (a == 1) ? 20: 30;\n      System.out.println(  Value of b is :   +  b );\n\n      b = (a == 10) ? 20: 30;\n      System.out.println(  Value of b is :   + b );\n   }\n}  This would produce the following result ?  Value of b is : 30\nValue of b is : 20", 
            "title": "Miscellaneous Operators"
        }, 
        {
            "location": "/basic_syntax/#precedence-of-operators", 
            "text": "Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator:  For example, x = 7 + 3 * 2; here x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.  Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.  Category    Operator    Associativity \nPostfix     () [] . (dot operator)  Left toright \nUnary   ++ - - ! ~  Right to left \nMultiplicative      * / %   Left to right \nAdditive    + -     Left to right \nShift           Left to right \nRelational         =    =   Left to right \nEquality    == !=   Left to right \nBitwise AND         Left to right \nBitwise XOR     ^   Left to right \nBitwise OR  |   Left to right \nLogical AND        Left to right \nLogical OR  ||  Left to right \nConditional     ?:  Right to left \nAssignment  = += -= *= /= %=  =  =  = ^= |=   Right to left", 
            "title": "Precedence of Operators"
        }, 
        {
            "location": "/basic_syntax/#conditional", 
            "text": "Java uses boolean variables to evaluate conditions. The boolean values  true  and  false  are returned when an expression is compared or evaluated. For example:  int a = 4;\nboolean b = a == 4;\n\nif (b) {\n    System.out.println( It's true! );\n}  Of course we don't normally assign a conditional expression to a boolean, we just use the short version:  int a = 4;\n\nif (a == 4) {\n    System.out.println( Ohhh! So a is 4! );\n}", 
            "title": "Conditional"
        }, 
        {
            "location": "/basic_syntax/#boolean-operators", 
            "text": "There aren't that many operators to use in conditional statements and most of them are pretty strait forward:  int a = 4;\nint b = 5;\nboolean result;\nresult = a   b; // true\nresult = a   b; // false\nresult = a  = 4 // a smaller or equal to 4 - true\nresult = b  = 6 // b bigger or equal to 6 - false\nresult = a == b // a equal to b - false\nresult = a != b // a is not equal to b - true\nresult = a   b || a   b // Logical or - true\nresult = 3   a   a   6 // Logical and - true\nresult = !result // Logical not - false", 
            "title": "Boolean operators"
        }, 
        {
            "location": "/basic_syntax/#if-else-and-between", 
            "text": "The if, else statement in java is pretty simple.  if (a == b) {\n    // a and b are equal, let's do something cool\n}  And we can also add an else statement after an if, to do something if the condition is not true  if (a == b) {\n    // We already know this part\n} else {\n    // a and b are not equal... :/\n}  The if - else statements doesn't have to be in several lines with {}, if can be used in one line, or without the {}, for a single line statment.  if (a == b)\n    System.out.println( Another line Wow! );\nelse\n    System.out.println( Double rainbow! );  Although this method might be useful for making your code shorter by using fewer lines, we strongly recommend for beginners not to use this short version of statements and always use the full version with {}. This goes to every statement that can be shorted to a single line (for, while, etc).", 
            "title": "if - else and between"
        }, 
        {
            "location": "/basic_syntax/#the-ugly-side-of-if", 
            "text": "There is a another way to write a one line if - else statement by using the operator ? :  int a = 4;\nint result = a == 4 ? 1 : 8;\n\n// result will be 1\n// This is equivalent to\nint result;\n\nif (a == 4) {\n    result = 1;\n} else {\n    result = 8;\n}  Again, we strongly recommend for beginners not to use this version of if.", 
            "title": "The ugly side of if"
        }, 
        {
            "location": "/basic_syntax/#and-equals", 
            "text": "The operator == works a bit different on objects than on primitives. When we are using objects and want to check if they are equal, the operator == will say if they are the same, if you want to check if they are logically equal, you should use the equals method on the object. For example:  String a = new String( Wow );\nString b = new String( Wow );\nString sameA = a;\n\nboolean r1 = a == b;      // This is false, since a and b are not the same object\nboolean r2 = a.equals(b); // This is true, since a and b are logically equals\nboolean r3 = a == sameA;  // This is true, since a and sameA are really the same object", 
            "title": "== and equals"
        }, 
        {
            "location": "/data_structure/", 
            "text": "Data Structure\n\n\ndatetime\n\n\nCalendar c = Calendar.getInstance();\n\n\n\n\nstring, number\n\n\nConvert \n1\n\n\nString.valueOf(1000)\n\n\n\n\nMake a random\n\n\n// create a random number from 0 to 99\n(new Random()).nextInt(100)\n\n\n\n\nCollection\n\n\nArrays\n\n\nArrays in Java are also objects. They need to be declared and then created. In order to declare a variable that will hold an array of integers, we use the following syntax:\n\n\nint[] arr;\n\n\n\n\nNotice there is no size, since we didn't create the array yet.\n\n\narr = new int[10];\n\n\n\n\nThis will create a new array with the size of 10. We can check the size by printing the array's length:\n\n\nSystem.out.println(arr.length);\n\n\n\n\nWe can access the array and set values:\n\n\narr[0] = 4;\narr[1] = arr[0] + 5;\n\n\n\n\nJava arrays are 0 based, which means the first element in an array is accessed at index 0 (e.g: arr[0], which accesses the first element). Also, as an example, an array of size 5 will only go up to index 4 due to it being 0 based.\n\n\nint[] arr = new int[5]\n//accesses and sets the first element\narr[0] = 4;\n\n\n\n\nWe can also create an array with values in the same line:\n\n\nint[] arr = {1, 2, 3, 4, 5};\n\n\n\n\nDon't try to print the array without a loop, it will print something nasty like [I@f7e6a96.\n\n\nSet\n\n\n\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class HelloWorld{\n\n     public static void main(String []args){\n         Set\nDog\n dogs = new  HashSet\nDog\n();\n         Dog dog1 = new Dog(\na\n, 1);\n         Dog dog2 = new Dog(\na\n, 2);\n         Dog dog3 = new Dog(\na\n, 1);\n         Dog dog4 = new Dog(\nb\n, 1);\n         dogs.add( dog1);\n         dogs.add( dog2);\n         dogs.add( dog3);\n         dogs.add( dog4);\n        System.out.println(dogs.size());\n     }\n}\n\n// 3\n\n\n\n\npublic class Dog {\n    public String name;\n    public int age;\n    public int value;\n    public Dog(String name, int age){\n        this.name = name;\n        this.age = age;\n        value = (this.name + String.valueOf(this.age)).hashCode();\n    }\n\n    @Override\n    public int hashCode() {\n        return value;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return (obj instanceof Dog \n ((Dog) obj).value == this.value);\n    }\n}\n\n\n\n\nList \n1\n\n\nList\nString\n places = Arrays.asList(\nBuenos Aires\n, \nC\u00f3rdoba\n, \nLa Plata\n);\n\n\n\n\n\n\n\n\n\n\n\n\nInitialization of an ArrayList in one line", 
            "title": "Data Structure"
        }, 
        {
            "location": "/data_structure/#data-structure", 
            "text": "", 
            "title": "Data Structure"
        }, 
        {
            "location": "/data_structure/#datetime", 
            "text": "Calendar c = Calendar.getInstance();", 
            "title": "datetime"
        }, 
        {
            "location": "/data_structure/#string-number", 
            "text": "Convert  1  String.valueOf(1000)  Make a random  // create a random number from 0 to 99\n(new Random()).nextInt(100)", 
            "title": "string, number"
        }, 
        {
            "location": "/data_structure/#collection", 
            "text": "", 
            "title": "Collection"
        }, 
        {
            "location": "/data_structure/#arrays", 
            "text": "Arrays in Java are also objects. They need to be declared and then created. In order to declare a variable that will hold an array of integers, we use the following syntax:  int[] arr;  Notice there is no size, since we didn't create the array yet.  arr = new int[10];  This will create a new array with the size of 10. We can check the size by printing the array's length:  System.out.println(arr.length);  We can access the array and set values:  arr[0] = 4;\narr[1] = arr[0] + 5;  Java arrays are 0 based, which means the first element in an array is accessed at index 0 (e.g: arr[0], which accesses the first element). Also, as an example, an array of size 5 will only go up to index 4 due to it being 0 based.  int[] arr = new int[5]\n//accesses and sets the first element\narr[0] = 4;  We can also create an array with values in the same line:  int[] arr = {1, 2, 3, 4, 5};  Don't try to print the array without a loop, it will print something nasty like [I@f7e6a96.", 
            "title": "Arrays"
        }, 
        {
            "location": "/data_structure/#set", 
            "text": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class HelloWorld{\n\n     public static void main(String []args){\n         Set Dog  dogs = new  HashSet Dog ();\n         Dog dog1 = new Dog( a , 1);\n         Dog dog2 = new Dog( a , 2);\n         Dog dog3 = new Dog( a , 1);\n         Dog dog4 = new Dog( b , 1);\n         dogs.add( dog1);\n         dogs.add( dog2);\n         dogs.add( dog3);\n         dogs.add( dog4);\n        System.out.println(dogs.size());\n     }\n}\n\n// 3  public class Dog {\n    public String name;\n    public int age;\n    public int value;\n    public Dog(String name, int age){\n        this.name = name;\n        this.age = age;\n        value = (this.name + String.valueOf(this.age)).hashCode();\n    }\n\n    @Override\n    public int hashCode() {\n        return value;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        return (obj instanceof Dog   ((Dog) obj).value == this.value);\n    }\n}", 
            "title": "Set"
        }, 
        {
            "location": "/data_structure/#list-1", 
            "text": "List String  places = Arrays.asList( Buenos Aires ,  C\u00f3rdoba ,  La Plata );      Initialization of an ArrayList in one line", 
            "title": "List 1"
        }, 
        {
            "location": "/oop/", 
            "text": "Java is an Object-Oriented Language. As a language that has the Object-Oriented feature, Java supports the following fundamental concepts\n\n\n\n\nClasses and Objects\n\n\nEncapsulation\n\n\nInheritance\n\n\nPolymorphism\n\n\nAbstraction\n\n\nInstance\n\n\nMethod\n\n\nMessage Parsing\n\n\n\n\nIn this chapter, we will look into the concepts - Classes and Objects.\n\n\n\n\nObject\n \u2212 Objects have states and behaviors. Example: A dog has states - color, name, breed as well as behaviors \u2013 wagging the tail, barking, eating. An object is an instance of a class.\n\n\nClass\n \u2212 A class can be defined as a template/blueprint that describes the behavior/state that the object of its type support.\n\n\n\n\nObjects\n\n\nLet us now look deep into what are objects. If we consider the real-world, we can find many objects around us, cars, dogs, humans, etc. All these objects have a state and a behavior.\n\n\nIf we consider a dog, then its state is - name, breed, color, and the behavior is - barking, wagging the tail, running.\n\n\nIf you compare the software object with a real-world object, they have very similar characteristics.\n\n\nSoftware objects also have a state and a behavior. A software object's state is stored in fields and behavior is shown via methods.\n\n\nSo in software development, methods operate on the internal state of an object and the object-to-object communication is done via methods.\n\n\nClasses\n\n\nA class is a blueprint from which individual objects are created.\n\n\nFollowing is a sample of a class.\n\n\nExample\n\n\npublic class Dog {\n   String breed;\n   int ageC\n   String color;\n\n   void barking() {\n   }\n\n   void hungry() {\n   }\n\n   void sleeping() {\n   }\n}\n\n\n\n\nA class can contain any of the following variable types.\n\n\n\n\nLocal variables\n \u2212 Variables defined inside methods, constructors or blocks are called local variables. The variable will be declared and initialized within the method and the variable will be destroyed when the method has completed.\n\n\nInstance variables\n \u2212 Instance variables are variables within a class but outside any method. These variables are initialized when the class is instantiated. Instance variables can be accessed from inside any method, constructor or blocks of that particular class.\n\n\nClass variables\n \u2212 Class variables are variables declared within a class, outside any method, with the static keyword.\n\n\n\n\nA class can have any number of methods to access the value of various kinds of methods. In the above example, barking(), hungry() and sleeping() are methods.\n\n\nFollowing are some of the important topics that need to be discussed when looking into classes of the Java Language.\n\n\nConstructors\n\n\nWhen discussing about classes, one of the most important sub topic would be constructors. Every class has a constructor. If we do not explicitly write a constructor for a class, the Java compiler builds a default constructor for that class.\n\n\nEach time a new object is created, at least one constructor will be invoked. The main rule of constructors is that they should have the same name as the class. A class can have more than one constructor.\n\n\nFollowing is an example of a constructor \u2212\n\n\nExample\n\n\npublic class Puppy {\n   public Puppy() {\n   }\n\n   public Puppy(String name) {\n      // This constructor has one parameter, name.\n   }\n}\n\n\n\n\nJava also supports Singleton Classes where you would be able to create only one instance of a class.\n\n\nNote\n \u2212 We have two different types of constructors. We are going to discuss constructors in detail in the subsequent chapters.\n\n\nCreating an Object\n\n\nAs mentioned previously, a class provides the blueprints for objects. So basically, an object is created from a class. In Java, the new keyword is used to create new objects.\n\n\nThere are three steps when creating an object from a class \u2212\n\n\n\n\nDeclaration\n \u2212 A variable declaration with a variable name with an object type.\n\n\nInstantiation\n \u2212 The 'new' keyword is used to create the object.\n\n\nInitialization\n \u2212 The 'new' keyword is followed by a call to a constructor. This call initializes the new object.\n\n\n\n\nFollowing is an example of creating an object \u2212\n\n\nExample\n\n\npublic class Puppy {\n   public Puppy(String name) {\n      // This constructor has one parameter, name.\n      System.out.println(\nPassed Name is :\n + name );\n   }\n\n   public static void main(String []args) {\n      // Following statement would create an object myPuppy\n      Puppy myPuppy = new Puppy( \ntommy\n );\n   }\n}\n\n\n\n\nIf we compile and run the above program, then it will produce the following result \u2212\n\n\nPassed Name is :tommy\n\n\n\n\nAccessing Instance Variables and Methods\n\n\nInstance variables and methods are accessed via created objects. To access an instance variable, following is the fully qualified path \u2212\n\n\n/* First create an object */\nObjectReference = new Constructor();\n\n/* Now call a variable as follows */\nObjectReference.variableName;\n\n/* Now you can call a class method as follows */\nObjectReference.MethodName();\n\n\n\n\nExample\n\n\nThis example explains how to access instance variables and methods of a class.\n\n\npublic class Puppy {\n   int puppyAge;\n\n   public Puppy(String name) {\n      // This constructor has one parameter, name.\n      System.out.println(\nName chosen is :\n + name );\n   }\n\n   public void setAge( int age ) {\n      puppyAge = age;\n   }\n\n   public int getAge( ) {\n      System.out.println(\nPuppy's age is :\n + puppyAge );\n      return puppyAge;\n   }\n\n   public static void main(String []args) {\n      /* Object creation */\n      Puppy myPuppy = new Puppy( \ntommy\n );\n\n      /* Call class method to set puppy's age */\n      myPuppy.setAge( 2 );\n\n      /* Call another class method to get puppy's age */\n      myPuppy.getAge( );\n\n      /* You can access instance variable as follows as well */\n      System.out.println(\nVariable Value :\n + myPuppy.puppyAge );\n   }\n}\n\n\n\n\nIf we compile and run the above program, then it will produce the following result\n\n\nOutput\n\n\nName chosen is :tommy\nPuppy's age is :2\nVariable Value :2\n\n\n\n\nSource File Declaration Rules\n\n\nAs the last part of this section, let's now look into the source file declaration rules. These rules are essential when declaring classes, import statements and package statements in a source file.\n\n\n\n\nThere can be only one public class per source file.\n\n\nA source file can have multiple non-public classes.\n\n\nThe public class name should be the name of the source file as well which should be appended by .java at the end. For example: the class name is public class Employee{} then the source file should be as Employee.java.\n\n\nIf the class is defined inside a package, then the package statement should be the first statement in the source file.\n\n\nIf import statements are present, then they must be written between the package statement and the class declaration. If there are no package statements, then the import statement should be the first line in the source file.\n\n\nImport and package statements will imply to all the classes present in the source file. It is not possible to declare different import and/or package statements to different classes in the source file.\n\n\n\n\nClasses have several access levels and there are different types of classes; abstract classes, final classes, etc. We will be explaining about all these in the access modifiers chapter.\n\n\nApart from the above mentioned types of classes, Java also has some special classes called Inner classes and Anonymous classes.\n\n\nJava Package\n\n\nIn simple words, it is a way of categorizing the classes and interfaces. When developing applications in Java, hundreds of classes and interfaces will be written, therefore categorizing these classes is a must as well as makes life much easier.\n\n\nImport Statements\n\n\nIn Java if a fully qualified name, which includes the package and the class name is given, then the compiler can easily locate the source code or classes. Import statement is a way of giving the proper location for the compiler to find that particular class.\n\n\nFor example, the following line would ask the compiler to load all the classes available in directory java_installation/java/io \u2212\n\n\nimport java.io.*;\n\n\n\n\nA Simple Case Study\n\n\nFor our case study, we will be creating two classes. They are Employee and EmployeeTest.\n\n\nFirst open notepad and add the following code. Remember this is the Employee class and the class is a public class. Now, save this source file with the name Employee.java.\n\n\nThe Employee class has four instance variables - name, age, designation and salary. The class has one explicitly defined constructor, which takes a parameter.\n\n\nExample\n\n\nimport java.io.*;\npublic class Employee {\n\n   String name;\n   int age;\n   String designation;\n   double salary;\n\n   // This is the constructor of the class Employee\n   public Employee(String name) {\n      this.name = name;\n   }\n\n   // Assign the age of the Employee  to the variable age.\n   public void empAge(int empAge) {\n      age = empAge;\n   }\n\n   /* Assign the designation to the variable designation.*/\n   public void empDesignation(String empDesig) {\n      designation = empDesig;\n   }\n\n   /* Assign the salary to the variable salary.*/\n   public void empSalary(double empSalary) {\n      salary = empSalary;\n   }\n\n   /* Print the Employee details */\n   public void printEmployee() {\n      System.out.println(\nName:\n+ name );\n      System.out.println(\nAge:\n + age );\n      System.out.println(\nDesignation:\n + designation );\n      System.out.println(\nSalary:\n + salary);\n   }\n}\n\n\n\n\nAs mentioned previously in this tutorial, processing starts from the main method. Therefore, in order for us to run this Employee class there should be a main method and objects should be created. We will be creating a separate class for these tasks.\n\n\nFollowing is the EmployeeTest class, which creates two instances of the class Employee and invokes the methods for each object to assign values for each variable.\n\n\nSave the following code in EmployeeTest.java file.\n\n\nimport java.io.*;\npublic class EmployeeTest {\n\n   public static void main(String args[]) {\n      /* Create two objects using constructor */\n      Employee empOne = new Employee(\nJames Smith\n);\n      Employee empTwo = new Employee(\nMary Anne\n);\n\n      // Invoking methods for each object created\n      empOne.empAge(26);\n      empOne.empDesignation(\nSenior Software Engineer\n);\n      empOne.empSalary(1000);\n      empOne.printEmployee();\n\n      empTwo.empAge(21);\n      empTwo.empDesignation(\nSoftware Engineer\n);\n      empTwo.empSalary(500);\n      empTwo.printEmployee();\n   }\n}\n\n\n\n\nNow, compile both the classes and then run EmployeeTest to see the result as follows \u2212\n\n\nOutput\n\n\nC:\\\n javac Employee.java\nC:\\\n javac EmployeeTest.java\nC:\\\n java EmployeeTest\nName:James Smith\nAge:26\nDesignation:Senior Software Engineer\nSalary:1000.0\nName:Mary Anne\nAge:21\nDesignation:Software Engineer\nSalary:500.0", 
            "title": "Overview"
        }, 
        {
            "location": "/oop/#objects", 
            "text": "Let us now look deep into what are objects. If we consider the real-world, we can find many objects around us, cars, dogs, humans, etc. All these objects have a state and a behavior.  If we consider a dog, then its state is - name, breed, color, and the behavior is - barking, wagging the tail, running.  If you compare the software object with a real-world object, they have very similar characteristics.  Software objects also have a state and a behavior. A software object's state is stored in fields and behavior is shown via methods.  So in software development, methods operate on the internal state of an object and the object-to-object communication is done via methods.", 
            "title": "Objects"
        }, 
        {
            "location": "/oop/#classes", 
            "text": "A class is a blueprint from which individual objects are created.  Following is a sample of a class.  Example  public class Dog {\n   String breed;\n   int ageC\n   String color;\n\n   void barking() {\n   }\n\n   void hungry() {\n   }\n\n   void sleeping() {\n   }\n}  A class can contain any of the following variable types.   Local variables  \u2212 Variables defined inside methods, constructors or blocks are called local variables. The variable will be declared and initialized within the method and the variable will be destroyed when the method has completed.  Instance variables  \u2212 Instance variables are variables within a class but outside any method. These variables are initialized when the class is instantiated. Instance variables can be accessed from inside any method, constructor or blocks of that particular class.  Class variables  \u2212 Class variables are variables declared within a class, outside any method, with the static keyword.   A class can have any number of methods to access the value of various kinds of methods. In the above example, barking(), hungry() and sleeping() are methods.  Following are some of the important topics that need to be discussed when looking into classes of the Java Language.", 
            "title": "Classes"
        }, 
        {
            "location": "/oop/#constructors", 
            "text": "When discussing about classes, one of the most important sub topic would be constructors. Every class has a constructor. If we do not explicitly write a constructor for a class, the Java compiler builds a default constructor for that class.  Each time a new object is created, at least one constructor will be invoked. The main rule of constructors is that they should have the same name as the class. A class can have more than one constructor.  Following is an example of a constructor \u2212  Example  public class Puppy {\n   public Puppy() {\n   }\n\n   public Puppy(String name) {\n      // This constructor has one parameter, name.\n   }\n}  Java also supports Singleton Classes where you would be able to create only one instance of a class.  Note  \u2212 We have two different types of constructors. We are going to discuss constructors in detail in the subsequent chapters.", 
            "title": "Constructors"
        }, 
        {
            "location": "/oop/#creating-an-object", 
            "text": "As mentioned previously, a class provides the blueprints for objects. So basically, an object is created from a class. In Java, the new keyword is used to create new objects.  There are three steps when creating an object from a class \u2212   Declaration  \u2212 A variable declaration with a variable name with an object type.  Instantiation  \u2212 The 'new' keyword is used to create the object.  Initialization  \u2212 The 'new' keyword is followed by a call to a constructor. This call initializes the new object.   Following is an example of creating an object \u2212  Example  public class Puppy {\n   public Puppy(String name) {\n      // This constructor has one parameter, name.\n      System.out.println( Passed Name is :  + name );\n   }\n\n   public static void main(String []args) {\n      // Following statement would create an object myPuppy\n      Puppy myPuppy = new Puppy(  tommy  );\n   }\n}  If we compile and run the above program, then it will produce the following result \u2212  Passed Name is :tommy", 
            "title": "Creating an Object"
        }, 
        {
            "location": "/oop/#accessing-instance-variables-and-methods", 
            "text": "Instance variables and methods are accessed via created objects. To access an instance variable, following is the fully qualified path \u2212  /* First create an object */\nObjectReference = new Constructor();\n\n/* Now call a variable as follows */\nObjectReference.variableName;\n\n/* Now you can call a class method as follows */\nObjectReference.MethodName();  Example  This example explains how to access instance variables and methods of a class.  public class Puppy {\n   int puppyAge;\n\n   public Puppy(String name) {\n      // This constructor has one parameter, name.\n      System.out.println( Name chosen is :  + name );\n   }\n\n   public void setAge( int age ) {\n      puppyAge = age;\n   }\n\n   public int getAge( ) {\n      System.out.println( Puppy's age is :  + puppyAge );\n      return puppyAge;\n   }\n\n   public static void main(String []args) {\n      /* Object creation */\n      Puppy myPuppy = new Puppy(  tommy  );\n\n      /* Call class method to set puppy's age */\n      myPuppy.setAge( 2 );\n\n      /* Call another class method to get puppy's age */\n      myPuppy.getAge( );\n\n      /* You can access instance variable as follows as well */\n      System.out.println( Variable Value :  + myPuppy.puppyAge );\n   }\n}  If we compile and run the above program, then it will produce the following result  Output  Name chosen is :tommy\nPuppy's age is :2\nVariable Value :2", 
            "title": "Accessing Instance Variables and Methods"
        }, 
        {
            "location": "/oop/#source-file-declaration-rules", 
            "text": "As the last part of this section, let's now look into the source file declaration rules. These rules are essential when declaring classes, import statements and package statements in a source file.   There can be only one public class per source file.  A source file can have multiple non-public classes.  The public class name should be the name of the source file as well which should be appended by .java at the end. For example: the class name is public class Employee{} then the source file should be as Employee.java.  If the class is defined inside a package, then the package statement should be the first statement in the source file.  If import statements are present, then they must be written between the package statement and the class declaration. If there are no package statements, then the import statement should be the first line in the source file.  Import and package statements will imply to all the classes present in the source file. It is not possible to declare different import and/or package statements to different classes in the source file.   Classes have several access levels and there are different types of classes; abstract classes, final classes, etc. We will be explaining about all these in the access modifiers chapter.  Apart from the above mentioned types of classes, Java also has some special classes called Inner classes and Anonymous classes.", 
            "title": "Source File Declaration Rules"
        }, 
        {
            "location": "/oop/#java-package", 
            "text": "In simple words, it is a way of categorizing the classes and interfaces. When developing applications in Java, hundreds of classes and interfaces will be written, therefore categorizing these classes is a must as well as makes life much easier.", 
            "title": "Java Package"
        }, 
        {
            "location": "/oop/#import-statements", 
            "text": "In Java if a fully qualified name, which includes the package and the class name is given, then the compiler can easily locate the source code or classes. Import statement is a way of giving the proper location for the compiler to find that particular class.  For example, the following line would ask the compiler to load all the classes available in directory java_installation/java/io \u2212  import java.io.*;", 
            "title": "Import Statements"
        }, 
        {
            "location": "/oop/#a-simple-case-study", 
            "text": "For our case study, we will be creating two classes. They are Employee and EmployeeTest.  First open notepad and add the following code. Remember this is the Employee class and the class is a public class. Now, save this source file with the name Employee.java.  The Employee class has four instance variables - name, age, designation and salary. The class has one explicitly defined constructor, which takes a parameter.  Example  import java.io.*;\npublic class Employee {\n\n   String name;\n   int age;\n   String designation;\n   double salary;\n\n   // This is the constructor of the class Employee\n   public Employee(String name) {\n      this.name = name;\n   }\n\n   // Assign the age of the Employee  to the variable age.\n   public void empAge(int empAge) {\n      age = empAge;\n   }\n\n   /* Assign the designation to the variable designation.*/\n   public void empDesignation(String empDesig) {\n      designation = empDesig;\n   }\n\n   /* Assign the salary to the variable salary.*/\n   public void empSalary(double empSalary) {\n      salary = empSalary;\n   }\n\n   /* Print the Employee details */\n   public void printEmployee() {\n      System.out.println( Name: + name );\n      System.out.println( Age:  + age );\n      System.out.println( Designation:  + designation );\n      System.out.println( Salary:  + salary);\n   }\n}  As mentioned previously in this tutorial, processing starts from the main method. Therefore, in order for us to run this Employee class there should be a main method and objects should be created. We will be creating a separate class for these tasks.  Following is the EmployeeTest class, which creates two instances of the class Employee and invokes the methods for each object to assign values for each variable.  Save the following code in EmployeeTest.java file.  import java.io.*;\npublic class EmployeeTest {\n\n   public static void main(String args[]) {\n      /* Create two objects using constructor */\n      Employee empOne = new Employee( James Smith );\n      Employee empTwo = new Employee( Mary Anne );\n\n      // Invoking methods for each object created\n      empOne.empAge(26);\n      empOne.empDesignation( Senior Software Engineer );\n      empOne.empSalary(1000);\n      empOne.printEmployee();\n\n      empTwo.empAge(21);\n      empTwo.empDesignation( Software Engineer );\n      empTwo.empSalary(500);\n      empTwo.printEmployee();\n   }\n}  Now, compile both the classes and then run EmployeeTest to see the result as follows \u2212  Output  C:\\  javac Employee.java\nC:\\  javac EmployeeTest.java\nC:\\  java EmployeeTest\nName:James Smith\nAge:26\nDesignation:Senior Software Engineer\nSalary:1000.0\nName:Mary Anne\nAge:21\nDesignation:Software Engineer\nSalary:500.0", 
            "title": "A Simple Case Study"
        }, 
        {
            "location": "/oop_encapsulation/", 
            "text": "Encapsulation\n is one of the four fundamental OOP concepts. The other three are inheritance, polymorphism, and abstraction.\n\n\nEncapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as a single unit. In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class. Therefore, it is also known as \ndata hiding\n.\n\n\nImplementation\n\n\nTo achieve encapsulation in Java\n\n\n\n\nDeclare the variables of a class as private.\n\n\nProvide public setter and getter methods to modify and view the variables values.\n\n\n\n\nExample\n\n\nFollowing is an example that demonstrates how to achieve Encapsulation in Java\n\n\n/* File name : EncapTest.java */\npublic class EncapTest {\n   private String name;\n   private String idNum;\n   private int age;\n\n   public int getAge() {\n      return age;\n   }\n\n   public String getName() {\n      return name;\n   }\n\n   public String getIdNum() {\n      return idNum;\n   }\n\n   public void setAge( int newAge) {\n      age = newAge;\n   }\n\n   public void setName(String newName) {\n      name = newName;\n   }\n\n   public void setIdNum( String newId) {\n      idNum = newId;\n   }\n}\n\n\n\n\nThe public setXXX() and getXXX() methods are the access points of the instance variables of the EncapTest class. Normally, these methods are referred as getters and setters. Therefore, any class that wants to access the variables should access them through these getters and setters.\n\n\nThe variables of the EncapTest class can be accessed using the following program \u2212\n\n\n/* File name : RunEncap.java */\npublic class RunEncap {\n\n   public static void main(String args[]) {\n      EncapTest encap = new EncapTest();\n      encap.setName(\nJames\n);\n      encap.setAge(20);\n      encap.setIdNum(\n12343ms\n);\n\n      System.out.print(\nName : \n + encap.getName() + \n Age : \n + encap.getAge());\n   }\n}\n\n\n\n\nThis will produce the following result \u2212\n\n\nName : James Age : 20\n\n\n\n\nBenefits\n\n\n\n\nThe fields of a class can be made read-only or write-only.\n\n\nA class can have total control over what is stored in its fields.\n\n\nThe users of a class do not know how the class stores its data. A class can change the data type of a field and users of the class do not need to change any of their code.\n\n\n\n\nRelated Readings\n\n\n\n\n\"Java Inheritance\". www.tutorialspoint.com. N.p., 2016. Web. 10 Dec. 2016.", 
            "title": "Encapsulation"
        }, 
        {
            "location": "/oop_encapsulation/#implementation", 
            "text": "To achieve encapsulation in Java   Declare the variables of a class as private.  Provide public setter and getter methods to modify and view the variables values.", 
            "title": "Implementation"
        }, 
        {
            "location": "/oop_encapsulation/#example", 
            "text": "Following is an example that demonstrates how to achieve Encapsulation in Java  /* File name : EncapTest.java */\npublic class EncapTest {\n   private String name;\n   private String idNum;\n   private int age;\n\n   public int getAge() {\n      return age;\n   }\n\n   public String getName() {\n      return name;\n   }\n\n   public String getIdNum() {\n      return idNum;\n   }\n\n   public void setAge( int newAge) {\n      age = newAge;\n   }\n\n   public void setName(String newName) {\n      name = newName;\n   }\n\n   public void setIdNum( String newId) {\n      idNum = newId;\n   }\n}  The public setXXX() and getXXX() methods are the access points of the instance variables of the EncapTest class. Normally, these methods are referred as getters and setters. Therefore, any class that wants to access the variables should access them through these getters and setters.  The variables of the EncapTest class can be accessed using the following program \u2212  /* File name : RunEncap.java */\npublic class RunEncap {\n\n   public static void main(String args[]) {\n      EncapTest encap = new EncapTest();\n      encap.setName( James );\n      encap.setAge(20);\n      encap.setIdNum( 12343ms );\n\n      System.out.print( Name :   + encap.getName() +   Age :   + encap.getAge());\n   }\n}  This will produce the following result \u2212  Name : James Age : 20", 
            "title": "Example"
        }, 
        {
            "location": "/oop_encapsulation/#benefits", 
            "text": "The fields of a class can be made read-only or write-only.  A class can have total control over what is stored in its fields.  The users of a class do not know how the class stores its data. A class can change the data type of a field and users of the class do not need to change any of their code.", 
            "title": "Benefits"
        }, 
        {
            "location": "/oop_encapsulation/#related-readings", 
            "text": "\"Java Inheritance\". www.tutorialspoint.com. N.p., 2016. Web. 10 Dec. 2016.", 
            "title": "Related Readings"
        }, 
        {
            "location": "/oop_inheritance/", 
            "text": "In the preceding lessons, you have seen inheritance mentioned several times. In the Java language, classes can be derived from other classes, thereby inheriting fields and methods from those classes.\n\n\nThe idea of inheritance is simple but powerful: When you want to create a new class and there is already a class that includes some of the code that you want, you can derive your new class from the existing class. In doing this, you can reuse the fields and methods of the existing class without having to write (and debug!) them yourself.\n\n\nA subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.\n\n\nClass Hierarchy\n\n\nThe Object class, defined in the java.lang package, defines and implements behavior common to all classes\u2014including the ones that you write. In the Java platform, many classes derive directly from Object, other classes derive from some of those classes, and so on, forming a hierarchy of classes.\n\n\n\n\n\n\n\n\n\nAt the top of the hierarchy, Object is the most general of all classes. Classes near the bottom of the hierarchy provide more specialized behavior.\n\n\nAn Example\n\n\nHere is the sample code for a possible implementation of a Bicycle class that was presented in the Classes and Objects lesson:\n\n\npublic class Bicycle {\n\n    // the Bicycle class has three fields\n    public int cadence;\n    public int gear;\n    public int speed;\n\n    // the Bicycle class has one constructor\n    public Bicycle(int startCadence, int startSpeed, int startGear) {\n        gear = startGear;\n        cadence = startCadence;\n        speed = startSpeed;\n    }\n\n    // the Bicycle class has four methods\n    public void setCadence(int newValue) {\n        cadence = newValue;\n    }\n\n    public void setGear(int newValue) {\n        gear = newValue;\n    }\n\n    public void applyBrake(int decrement) {\n        speed -= decrement;\n    }\n\n    public void speedUp(int increment) {\n        speed += increment;\n    }\n\n}\n\n\n\n\nA class declaration for a MountainBike class that is a subclass of Bicycle might look like this:\n\n\npublic class MountainBike extends Bicycle {\n\n    // the MountainBike subclass adds one field\n    public int seatHeight;\n\n    // the MountainBike subclass has one constructor\n    public MountainBike(int startHeight,\n                        int startCadence,\n                        int startSpeed,\n                        int startGear) {\n        super(startCadence, startSpeed, startGear);\n        seatHeight = startHeight;\n    }\n\n    // the MountainBike subclass adds one method\n    public void setHeight(int newValue) {\n        seatHeight = newValue;\n    }\n}\n\n\n\n\nMountainBike inherits all the fields and methods of Bicycle and adds the field seatHeight and a method to set it. Except for the constructor, it is as if you had written a new MountainBike class entirely from scratch, with four fields and five methods. However, you didn't have to do all the work. This would be especially valuable if the methods in the Bicycle class were complex and had taken substantial time to debug.\n\n\nWhat You Can Do in a Subclass\n\n\nA subclass inherits all of the public and protected members of its parent, no matter what package the subclass is in. If the subclass is in the same package as its parent, it also inherits the package-private members of the parent. You can use the inherited members as is, replace them, hide them, or supplement them with new members:\n\n\n\n\nThe inherited fields can be used directly, just like any other fields.\n\n\nYou can declare a field in the subclass with the same name as the one in the superclass, thus hiding it (not * recommended).\n\n\nYou can declare new fields in the subclass that are not in the superclass.\n\n\nThe inherited methods can be used directly as they are.\n\n\nYou can write a new instance method in the subclass that has the same signature as the one in the superclass, thus  overriding it.\n\n\nYou can write a new static method in the subclass that has the same signature as the one in the superclass, thus hiding it.\n\n\nYou can declare new methods in the subclass that are not in the superclass.\n\n\nYou can write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the keyword super.\n\n\n\n\nThe following sections in this lesson will expand on these topics.\n\n\nPrivate Members in a Superclass\n\n\nA subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.\n\n\nA nested class has access to all the private members of its enclosing class\u2014both fields and methods. Therefore, a public or protected nested class inherited by a subclass has indirect access to all of the private members of the superclass.\n\n\nCasting Objects\n\n\nWe have seen that an object is of the data type of the class from which it was instantiated. For example, if we write\n\n\npublic MountainBike myBike = new MountainBike();\n\n\n\n\nthen myBike is of type MountainBike.\n\n\nMountainBike is descended from Bicycle and Object. Therefore, a MountainBike is a Bicycle and is also an Object, and it can be used wherever Bicycle or Object objects are called for.\n\n\nThe reverse is not necessarily true: a Bicycle may be a MountainBike, but it isn't necessarily. Similarly, an Object may be a Bicycle or a MountainBike, but it isn't necessarily.\n\n\nCasting shows the use of an object of one type in place of another type, among the objects permitted by inheritance and implementations. For example, if we write\n\n\nObject obj = new MountainBike();\n\n\n\n\nthen obj is both an Object and a MountainBike (until such time as obj is assigned another object that is not a MountainBike). This is called implicit casting.\n\n\nIf, on the other hand, we write\n\n\nMountainBike myBike = obj;\n\n\n\n\nwe would get a compile-time error because obj is not known to the compiler to be a MountainBike. However, we can tell the compiler that we promise to assign a MountainBike to obj by explicit casting:\n\n\nMountainBike myBike = (MountainBike)obj;\n\n\n\n\nThis cast inserts a runtime check that obj is assigned a MountainBike so that the compiler can safely assume that obj is a MountainBike. If obj is not a MountainBike at runtime, an exception will be thrown.\n\n\nRelated Readings\n\n\n\n\n\"Inheritance\". \ndocs.oracle.com\n. N.p., 2016. Web. 8 Dec. 2016.\n\n\n\"Java Inheritance\". \nwww.tutorialspoint.com\n. N.p., 2016. Web. 8 Dec. 2016.\n\n\nFriesen, Jeff. \"Java 101: Inheritance In Java, Part 1\". \nJavaWorld\n. N.p., 2016. Web. 8 Dec. 2016.", 
            "title": "Inheritance"
        }, 
        {
            "location": "/oop_inheritance/#class-hierarchy", 
            "text": "The Object class, defined in the java.lang package, defines and implements behavior common to all classes\u2014including the ones that you write. In the Java platform, many classes derive directly from Object, other classes derive from some of those classes, and so on, forming a hierarchy of classes.     At the top of the hierarchy, Object is the most general of all classes. Classes near the bottom of the hierarchy provide more specialized behavior.", 
            "title": "Class Hierarchy"
        }, 
        {
            "location": "/oop_inheritance/#an-example", 
            "text": "Here is the sample code for a possible implementation of a Bicycle class that was presented in the Classes and Objects lesson:  public class Bicycle {\n\n    // the Bicycle class has three fields\n    public int cadence;\n    public int gear;\n    public int speed;\n\n    // the Bicycle class has one constructor\n    public Bicycle(int startCadence, int startSpeed, int startGear) {\n        gear = startGear;\n        cadence = startCadence;\n        speed = startSpeed;\n    }\n\n    // the Bicycle class has four methods\n    public void setCadence(int newValue) {\n        cadence = newValue;\n    }\n\n    public void setGear(int newValue) {\n        gear = newValue;\n    }\n\n    public void applyBrake(int decrement) {\n        speed -= decrement;\n    }\n\n    public void speedUp(int increment) {\n        speed += increment;\n    }\n\n}  A class declaration for a MountainBike class that is a subclass of Bicycle might look like this:  public class MountainBike extends Bicycle {\n\n    // the MountainBike subclass adds one field\n    public int seatHeight;\n\n    // the MountainBike subclass has one constructor\n    public MountainBike(int startHeight,\n                        int startCadence,\n                        int startSpeed,\n                        int startGear) {\n        super(startCadence, startSpeed, startGear);\n        seatHeight = startHeight;\n    }\n\n    // the MountainBike subclass adds one method\n    public void setHeight(int newValue) {\n        seatHeight = newValue;\n    }\n}  MountainBike inherits all the fields and methods of Bicycle and adds the field seatHeight and a method to set it. Except for the constructor, it is as if you had written a new MountainBike class entirely from scratch, with four fields and five methods. However, you didn't have to do all the work. This would be especially valuable if the methods in the Bicycle class were complex and had taken substantial time to debug.", 
            "title": "An Example"
        }, 
        {
            "location": "/oop_inheritance/#what-you-can-do-in-a-subclass", 
            "text": "A subclass inherits all of the public and protected members of its parent, no matter what package the subclass is in. If the subclass is in the same package as its parent, it also inherits the package-private members of the parent. You can use the inherited members as is, replace them, hide them, or supplement them with new members:   The inherited fields can be used directly, just like any other fields.  You can declare a field in the subclass with the same name as the one in the superclass, thus hiding it (not * recommended).  You can declare new fields in the subclass that are not in the superclass.  The inherited methods can be used directly as they are.  You can write a new instance method in the subclass that has the same signature as the one in the superclass, thus  overriding it.  You can write a new static method in the subclass that has the same signature as the one in the superclass, thus hiding it.  You can declare new methods in the subclass that are not in the superclass.  You can write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the keyword super.   The following sections in this lesson will expand on these topics.", 
            "title": "What You Can Do in a Subclass"
        }, 
        {
            "location": "/oop_inheritance/#private-members-in-a-superclass", 
            "text": "A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.  A nested class has access to all the private members of its enclosing class\u2014both fields and methods. Therefore, a public or protected nested class inherited by a subclass has indirect access to all of the private members of the superclass.", 
            "title": "Private Members in a Superclass"
        }, 
        {
            "location": "/oop_inheritance/#casting-objects", 
            "text": "We have seen that an object is of the data type of the class from which it was instantiated. For example, if we write  public MountainBike myBike = new MountainBike();  then myBike is of type MountainBike.  MountainBike is descended from Bicycle and Object. Therefore, a MountainBike is a Bicycle and is also an Object, and it can be used wherever Bicycle or Object objects are called for.  The reverse is not necessarily true: a Bicycle may be a MountainBike, but it isn't necessarily. Similarly, an Object may be a Bicycle or a MountainBike, but it isn't necessarily.  Casting shows the use of an object of one type in place of another type, among the objects permitted by inheritance and implementations. For example, if we write  Object obj = new MountainBike();  then obj is both an Object and a MountainBike (until such time as obj is assigned another object that is not a MountainBike). This is called implicit casting.  If, on the other hand, we write  MountainBike myBike = obj;  we would get a compile-time error because obj is not known to the compiler to be a MountainBike. However, we can tell the compiler that we promise to assign a MountainBike to obj by explicit casting:  MountainBike myBike = (MountainBike)obj;  This cast inserts a runtime check that obj is assigned a MountainBike so that the compiler can safely assume that obj is a MountainBike. If obj is not a MountainBike at runtime, an exception will be thrown.", 
            "title": "Casting Objects"
        }, 
        {
            "location": "/oop_inheritance/#related-readings", 
            "text": "\"Inheritance\".  docs.oracle.com . N.p., 2016. Web. 8 Dec. 2016.  \"Java Inheritance\".  www.tutorialspoint.com . N.p., 2016. Web. 8 Dec. 2016.  Friesen, Jeff. \"Java 101: Inheritance In Java, Part 1\".  JavaWorld . N.p., 2016. Web. 8 Dec. 2016.", 
            "title": "Related Readings"
        }, 
        {
            "location": "/oop_polymorphism/", 
            "text": "Polymorphism\n is the ability of an object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object.\n\n\nAny Java object that can pass more than one IS-A test is considered to be polymorphic. In Java, all Java objects are polymorphic since any object will pass the IS-A test for their own type and for the class Object.\n\n\nIt is important to know that the only possible way to access an object is through a reference variable. A reference variable can be of only one type. Once declared, the type of a reference variable cannot be changed.\n\n\nThe reference variable can be reassigned to other objects provided that it is not declared final. The type of the reference variable would determine the methods that it can invoke on the object.\n\n\nA reference variable can refer to any object of its declared type or any subtype of its declared type. A reference variable can be declared as a class or interface type.\n\n\nExample\n\n\nLet us look at an example.\n\n\npublic interface Vegetarian{}\npublic class Animal{}\npublic class Deer extends Animal implements Vegetarian{}\n\n\n\n\nNow, the Deer class is considered to be polymorphic since this has multiple inheritance. Following are true for the above examples\n\n\n\n\nA Deer IS-A Animal\n\n\nA Deer IS-A Vegetarian\n\n\nA Deer IS-A Deer\n\n\nA Deer IS-A Object\n\n\n\n\nWhen we apply the reference variable facts to a Deer object reference, the following declarations are legal\n\n\nDeer d = new Deer();\nAnimal a = d;\nVegetarian v = d;\nObject o = d;\n\n\n\n\nAll the reference variables d, a, v, o refer to the same Deer object in the heap.\n\n\nVirtual Methods\n\n\nIn this section, I will show you how the behavior of overridden methods in Java allows you to take advantage of polymorphism when designing your classes.\n\n\nWe already have discussed method overriding, where a child class can override a method in its parent. An overridden method is essentially hidden in the parent class, and is not invoked unless the child class uses the super keyword within the overriding method.\n\n\n/* File name : Employee.java */\npublic class Employee {\n   private String name;\n   private String address;\n   private int number;\n\n   public Employee(String name, String address, int number) {\n      System.out.println(\nConstructing an Employee\n);\n      this.name = name;\n      this.address = address;\n      this.number = number;\n   }\n\n   public void mailCheck() {\n      System.out.println(\nMailing a check to \n + this.name + \n \n + this.address);\n   }\n\n   public String toString() {\n      return name + \n \n + address + \n \n + number;\n   }\n\n   public String getName() {\n      return name;\n   }\n\n   public String getAddress() {\n      return address;\n   }\n\n   public void setAddress(String newAddress) {\n      address = newAddress;\n   }\n\n   public int getNumber() {\n      return number;\n   }\n}\n\n\n\n\nNow suppose we extend Employee class as follows\n\n\n/* File name : Salary.java */\npublic class Salary extends Employee {\n   private double salary; // Annual salary\n\n   public Salary(String name, String address, int number, double salary) {\n      super(name, address, number);\n      setSalary(salary);\n   }\n\n   public void mailCheck() {\n      System.out.println(\nWithin mailCheck of Salary class \n);\n      System.out.println(\nMailing check to \n + getName()\n      + \n with salary \n + salary);\n   }\n\n   public double getSalary() {\n      return salary;\n   }\n\n   public void setSalary(double newSalary) {\n      if(newSalary \n= 0.0) {\n         salary = newSalary;\n      }\n   }\n\n   public double computePay() {\n      System.out.println(\nComputing salary pay for \n + getName());\n      return salary/52;\n   }\n}\n\n\n\n\nNow, you study the following program carefully and try to determine its output\n\n\n/* File name : VirtualDemo.java */\npublic class VirtualDemo {\n\n   public static void main(String [] args) {\n      Salary s = new Salary(\nMohd Mohtashim\n, \nAmbehta, UP\n, 3, 3600.00);\n      Employee e = new Salary(\nJohn Adams\n, \nBoston, MA\n, 2, 2400.00);\n      System.out.println(\nCall mailCheck using Salary reference --\n);\n      s.mailCheck();\n      System.out.println(\n\\n Call mailCheck using Employee reference--\n);\n      e.mailCheck();\n   }\n}\n\n\n\n\nThis will produce the following result\n\n\nConstructing an Employee\nConstructing an Employee\n\nCall mailCheck using Salary reference --\nWithin mailCheck of Salary class\nMailing check to Mohd Mohtashim with salary 3600.0\n\nCall mailCheck using Employee reference--\nWithin mailCheck of Salary class\nMailing check to John Adams with salary 2400.0\n\n\n\n\nHere, we instantiate two Salary objects. One using a Salary reference \ns\n, and the other using an Employee reference \ne\n.\n\n\nWhile invoking \ns.mailCheck()\n, the compiler sees \nmailCheck()\n in the Salary class at compile time, and the JVM invokes \nmailCheck()\n in the Salary class at run time.\n\n\nmailCheck()\n on \ne\n is quite different because \ne\n is an Employee reference. When the compiler sees \ne.mailCheck()\n, the compiler sees the \nmailCheck()\n method in the Employee class.\n\n\nHere, at compile time, the compiler used mailCheck() in Employee to validate this statement. At run time, however, the JVM invokes mailCheck() in the Salary class.\n\n\nThis behavior is referred to as virtual method invocation, and these methods are referred to as virtual methods. An overridden method is invoked at run time, no matter what data type the reference is that was used in the source code at compile time.\n\n\nRelated Readings\n\n\n\n\n\"Java Polymorphism\". \nwww.tutorialspoint.com\n. N.p., 2016. Web. 10 Dec. 2016.", 
            "title": "Polymorphism"
        }, 
        {
            "location": "/oop_polymorphism/#example", 
            "text": "Let us look at an example.  public interface Vegetarian{}\npublic class Animal{}\npublic class Deer extends Animal implements Vegetarian{}  Now, the Deer class is considered to be polymorphic since this has multiple inheritance. Following are true for the above examples   A Deer IS-A Animal  A Deer IS-A Vegetarian  A Deer IS-A Deer  A Deer IS-A Object   When we apply the reference variable facts to a Deer object reference, the following declarations are legal  Deer d = new Deer();\nAnimal a = d;\nVegetarian v = d;\nObject o = d;  All the reference variables d, a, v, o refer to the same Deer object in the heap.", 
            "title": "Example"
        }, 
        {
            "location": "/oop_polymorphism/#virtual-methods", 
            "text": "In this section, I will show you how the behavior of overridden methods in Java allows you to take advantage of polymorphism when designing your classes.  We already have discussed method overriding, where a child class can override a method in its parent. An overridden method is essentially hidden in the parent class, and is not invoked unless the child class uses the super keyword within the overriding method.  /* File name : Employee.java */\npublic class Employee {\n   private String name;\n   private String address;\n   private int number;\n\n   public Employee(String name, String address, int number) {\n      System.out.println( Constructing an Employee );\n      this.name = name;\n      this.address = address;\n      this.number = number;\n   }\n\n   public void mailCheck() {\n      System.out.println( Mailing a check to   + this.name +     + this.address);\n   }\n\n   public String toString() {\n      return name +     + address +     + number;\n   }\n\n   public String getName() {\n      return name;\n   }\n\n   public String getAddress() {\n      return address;\n   }\n\n   public void setAddress(String newAddress) {\n      address = newAddress;\n   }\n\n   public int getNumber() {\n      return number;\n   }\n}  Now suppose we extend Employee class as follows  /* File name : Salary.java */\npublic class Salary extends Employee {\n   private double salary; // Annual salary\n\n   public Salary(String name, String address, int number, double salary) {\n      super(name, address, number);\n      setSalary(salary);\n   }\n\n   public void mailCheck() {\n      System.out.println( Within mailCheck of Salary class  );\n      System.out.println( Mailing check to   + getName()\n      +   with salary   + salary);\n   }\n\n   public double getSalary() {\n      return salary;\n   }\n\n   public void setSalary(double newSalary) {\n      if(newSalary  = 0.0) {\n         salary = newSalary;\n      }\n   }\n\n   public double computePay() {\n      System.out.println( Computing salary pay for   + getName());\n      return salary/52;\n   }\n}  Now, you study the following program carefully and try to determine its output  /* File name : VirtualDemo.java */\npublic class VirtualDemo {\n\n   public static void main(String [] args) {\n      Salary s = new Salary( Mohd Mohtashim ,  Ambehta, UP , 3, 3600.00);\n      Employee e = new Salary( John Adams ,  Boston, MA , 2, 2400.00);\n      System.out.println( Call mailCheck using Salary reference -- );\n      s.mailCheck();\n      System.out.println( \\n Call mailCheck using Employee reference-- );\n      e.mailCheck();\n   }\n}  This will produce the following result  Constructing an Employee\nConstructing an Employee\n\nCall mailCheck using Salary reference --\nWithin mailCheck of Salary class\nMailing check to Mohd Mohtashim with salary 3600.0\n\nCall mailCheck using Employee reference--\nWithin mailCheck of Salary class\nMailing check to John Adams with salary 2400.0  Here, we instantiate two Salary objects. One using a Salary reference  s , and the other using an Employee reference  e .  While invoking  s.mailCheck() , the compiler sees  mailCheck()  in the Salary class at compile time, and the JVM invokes  mailCheck()  in the Salary class at run time.  mailCheck()  on  e  is quite different because  e  is an Employee reference. When the compiler sees  e.mailCheck() , the compiler sees the  mailCheck()  method in the Employee class.  Here, at compile time, the compiler used mailCheck() in Employee to validate this statement. At run time, however, the JVM invokes mailCheck() in the Salary class.  This behavior is referred to as virtual method invocation, and these methods are referred to as virtual methods. An overridden method is invoked at run time, no matter what data type the reference is that was used in the source code at compile time.", 
            "title": "Virtual Methods"
        }, 
        {
            "location": "/oop_polymorphism/#related-readings", 
            "text": "\"Java Polymorphism\".  www.tutorialspoint.com . N.p., 2016. Web. 10 Dec. 2016.", 
            "title": "Related Readings"
        }, 
        {
            "location": "/oop_abstraction/", 
            "text": "As per dictionary, \nabstraction\n is the quality of dealing with ideas rather than events. For example, when you consider the case of e-mail, complex details such as what happens as soon as you send an e-mail, the protocol your e-mail server uses are hidden from the user. Therefore, to send an e-mail you just need to type the content, mention the address of the receiver, and click send.\n\n\nLikewise in Object-oriented programming, abstraction is a process of hiding the implementation details from the user, only the functionality will be provided to the user. In other words, the user will have the information on what the object does instead of how it does it.\n\n\nIn Java, abstraction is achieved using Abstract classes and interfaces.\n\n\nAbstract Class\n\n\nA class which contains the abstract keyword in its declaration is known as abstract class.\n\n\n\n\nAbstract classes may or may not contain abstract methods, i.e., methods without body ( public void get(); )\n\n\nBut, if a class has at least one abstract method, then the class must be declared abstract.\n\n\nIf a class is declared abstract, it cannot be instantiated.\n\n\nTo use an abstract class, you have to inherit it from another class, provide implementations to the abstract methods in it.\n\n\nIf you inherit an abstract class, you have to provide implementations to all the abstract methods in it.\n\n\n\n\nExample\n\n\nThis section provides you an example of the abstract class. To create an abstract class, just use the \nabstract\n keyword before the class keyword, in the class declaration.\n\n\n/* File name : Employee.java */\npublic abstract class Employee {\n   private String name;\n   private String address;\n   private int number;\n\n   public Employee(String name, String address, int number) {\n      System.out.println(\nConstructing an Employee\n);\n      this.name = name;\n      this.address = address;\n      this.number = number;\n   }\n\n   public double computePay() {\n     System.out.println(\nInside Employee computePay\n);\n     return 0.0;\n   }\n\n   public void mailCheck() {\n      System.out.println(\nMailing a check to \n + this.name + \n \n + this.address);\n   }\n\n   public String toString() {\n      return name + \n \n + address + \n \n + number;\n   }\n\n   public String getName() {\n      return name;\n   }\n\n   public String getAddress() {\n      return address;\n   }\n\n   public void setAddress(String newAddress) {\n      address = newAddress;\n   }\n\n   public int getNumber() {\n      return number;\n   }\n}\n\n\n\n\nYou can observe that except abstract methods the Employee class is same as normal class in Java. The class is now abstract, but it still has three fields, seven methods, and one constructor.\n\n\nNow you can try to instantiate the Employee class in the following way\n\n\n/* File name : AbstractDemo.java */\npublic class AbstractDemo {\n\n   public static void main(String [] args) {\n      /* Following is not allowed and would raise error */\n      Employee e = new Employee(\nGeorge W.\n, \nHouston, TX\n, 43);\n      System.out.println(\n\\n Call mailCheck using Employee reference--\n);\n      e.mailCheck();\n   }\n}\n\n\n\n\nWhen you compile the above class, it gives you the following error\n\n\nEmployee.java:46: Employee is abstract; cannot be instantiated\n      Employee e = new Employee(\nGeorge W.\n, \nHouston, TX\n, 43);\n                   ^\n1 error\n\n\n\n\nInheriting the Abstract Class\n\n\nWe can inherit the properties of Employee class just like concrete class in the following way\n\n\n/* File name : Salary.java */\npublic class Salary extends Employee {\n   private double salary;   // Annual salary\n\n   public Salary(String name, String address, int number, double salary) {\n      super(name, address, number);\n      setSalary(salary);\n   }\n\n   public void mailCheck() {\n      System.out.println(\nWithin mailCheck of Salary class \n);\n      System.out.println(\nMailing check to \n + getName() + \n with salary \n + salary);\n   }\n\n   public double getSalary() {\n      return salary;\n   }\n\n   public void setSalary(double newSalary) {\n      if(newSalary \n= 0.0) {\n         salary = newSalary;\n      }\n   }\n\n   public double computePay() {\n      System.out.println(\nComputing salary pay for \n + getName());\n      return salary/52;\n   }\n}\n\n\n\n\nHere, you cannot instantiate the Employee class, but you can instantiate the Salary Class, and using this instance you can access all the three fields and seven methods of Employee class as shown below.\n\n\n/* File name : AbstractDemo.java */\npublic class AbstractDemo {\n\n   public static void main(String [] args) {\n      Salary s = new Salary(\nMohd Mohtashim\n, \nAmbehta, UP\n, 3, 3600.00);\n      Employee e = new Salary(\nJohn Adams\n, \nBoston, MA\n, 2, 2400.00);\n      System.out.println(\nCall mailCheck using Salary reference --\n);\n      s.mailCheck();\n      System.out.println(\n\\nCall mailCheck using Employee reference--\n);\n      e.mailCheck();\n   }\n}\n\n\n\n\nThis produces the following result\n\n\nConstructing an Employee\nConstructing an Employee\nCall mailCheck using Salary reference --\nWithin mailCheck of Salary class\nMailing check to Mohd Mohtashim with salary 3600.0\n\nCall mailCheck using Employee reference--\nWithin mailCheck of Salary class\nMailing check to John Adams with salary 2400.0\n\n\n\n\nAbstract Methods\n\n\nIf you want a class to contain a particular method but you want the actual implementation of that method to be determined by child classes, you can declare the method in the parent class as an abstract.\n\n\n\n\nabstract keyword is used to declare the method as abstract.\n\n\nYou have to place the abstract keyword before the method name in the method declaration.\n\n\nAn abstract method contains a method signature, but no method body.\n\n\nInstead of curly braces, an abstract method will have a semoi colon (;) at the end.\n\n\n\n\nFollowing is an example of the abstract method.\n\n\npublic abstract class Employee {\n   private String name;\n   private String address;\n   private int number;\n\n   public abstract double computePay();\n   // Remainder of class definition\n}\n\n\n\n\nDeclaring a method as abstract has two consequences\n\n\n\n\nThe class containing it must be declared as abstract.\n\n\nAny class inheriting the current class must either override the abstract method or declare itself as abstract.\n\n\n\n\nNote\n \u2212 Eventually, a descendant class has to implement the abstract method; otherwise, you would have a hierarchy of abstract classes that cannot be instantiated.\n\n\nSuppose Salary class inherits the Employee class, then it should implement the \ncomputePay()\n method as shown below\n\n\n/* File name : Salary.java */\npublic class Salary extends Employee {\n   private double salary;   // Annual salary\n\n   public double computePay() {\n      System.out.println(\nComputing salary pay for \n + getName());\n      return salary/52;\n   }\n   // Remainder of class definition\n}\n\n\n\n\nRelated Readings\n\n\n\n\n\"Java Abstraction\". \nwww.tutorialspoint.com\n. N.p., 2016. Web. 10 Dec. 2016.", 
            "title": "Abstraction"
        }, 
        {
            "location": "/oop_abstraction/#abstract-class", 
            "text": "A class which contains the abstract keyword in its declaration is known as abstract class.   Abstract classes may or may not contain abstract methods, i.e., methods without body ( public void get(); )  But, if a class has at least one abstract method, then the class must be declared abstract.  If a class is declared abstract, it cannot be instantiated.  To use an abstract class, you have to inherit it from another class, provide implementations to the abstract methods in it.  If you inherit an abstract class, you have to provide implementations to all the abstract methods in it.   Example  This section provides you an example of the abstract class. To create an abstract class, just use the  abstract  keyword before the class keyword, in the class declaration.  /* File name : Employee.java */\npublic abstract class Employee {\n   private String name;\n   private String address;\n   private int number;\n\n   public Employee(String name, String address, int number) {\n      System.out.println( Constructing an Employee );\n      this.name = name;\n      this.address = address;\n      this.number = number;\n   }\n\n   public double computePay() {\n     System.out.println( Inside Employee computePay );\n     return 0.0;\n   }\n\n   public void mailCheck() {\n      System.out.println( Mailing a check to   + this.name +     + this.address);\n   }\n\n   public String toString() {\n      return name +     + address +     + number;\n   }\n\n   public String getName() {\n      return name;\n   }\n\n   public String getAddress() {\n      return address;\n   }\n\n   public void setAddress(String newAddress) {\n      address = newAddress;\n   }\n\n   public int getNumber() {\n      return number;\n   }\n}  You can observe that except abstract methods the Employee class is same as normal class in Java. The class is now abstract, but it still has three fields, seven methods, and one constructor.  Now you can try to instantiate the Employee class in the following way  /* File name : AbstractDemo.java */\npublic class AbstractDemo {\n\n   public static void main(String [] args) {\n      /* Following is not allowed and would raise error */\n      Employee e = new Employee( George W. ,  Houston, TX , 43);\n      System.out.println( \\n Call mailCheck using Employee reference-- );\n      e.mailCheck();\n   }\n}  When you compile the above class, it gives you the following error  Employee.java:46: Employee is abstract; cannot be instantiated\n      Employee e = new Employee( George W. ,  Houston, TX , 43);\n                   ^\n1 error", 
            "title": "Abstract Class"
        }, 
        {
            "location": "/oop_abstraction/#inheriting-the-abstract-class", 
            "text": "We can inherit the properties of Employee class just like concrete class in the following way  /* File name : Salary.java */\npublic class Salary extends Employee {\n   private double salary;   // Annual salary\n\n   public Salary(String name, String address, int number, double salary) {\n      super(name, address, number);\n      setSalary(salary);\n   }\n\n   public void mailCheck() {\n      System.out.println( Within mailCheck of Salary class  );\n      System.out.println( Mailing check to   + getName() +   with salary   + salary);\n   }\n\n   public double getSalary() {\n      return salary;\n   }\n\n   public void setSalary(double newSalary) {\n      if(newSalary  = 0.0) {\n         salary = newSalary;\n      }\n   }\n\n   public double computePay() {\n      System.out.println( Computing salary pay for   + getName());\n      return salary/52;\n   }\n}  Here, you cannot instantiate the Employee class, but you can instantiate the Salary Class, and using this instance you can access all the three fields and seven methods of Employee class as shown below.  /* File name : AbstractDemo.java */\npublic class AbstractDemo {\n\n   public static void main(String [] args) {\n      Salary s = new Salary( Mohd Mohtashim ,  Ambehta, UP , 3, 3600.00);\n      Employee e = new Salary( John Adams ,  Boston, MA , 2, 2400.00);\n      System.out.println( Call mailCheck using Salary reference -- );\n      s.mailCheck();\n      System.out.println( \\nCall mailCheck using Employee reference-- );\n      e.mailCheck();\n   }\n}  This produces the following result  Constructing an Employee\nConstructing an Employee\nCall mailCheck using Salary reference --\nWithin mailCheck of Salary class\nMailing check to Mohd Mohtashim with salary 3600.0\n\nCall mailCheck using Employee reference--\nWithin mailCheck of Salary class\nMailing check to John Adams with salary 2400.0", 
            "title": "Inheriting the Abstract Class"
        }, 
        {
            "location": "/oop_abstraction/#abstract-methods", 
            "text": "If you want a class to contain a particular method but you want the actual implementation of that method to be determined by child classes, you can declare the method in the parent class as an abstract.   abstract keyword is used to declare the method as abstract.  You have to place the abstract keyword before the method name in the method declaration.  An abstract method contains a method signature, but no method body.  Instead of curly braces, an abstract method will have a semoi colon (;) at the end.   Following is an example of the abstract method.  public abstract class Employee {\n   private String name;\n   private String address;\n   private int number;\n\n   public abstract double computePay();\n   // Remainder of class definition\n}  Declaring a method as abstract has two consequences   The class containing it must be declared as abstract.  Any class inheriting the current class must either override the abstract method or declare itself as abstract.   Note  \u2212 Eventually, a descendant class has to implement the abstract method; otherwise, you would have a hierarchy of abstract classes that cannot be instantiated.  Suppose Salary class inherits the Employee class, then it should implement the  computePay()  method as shown below  /* File name : Salary.java */\npublic class Salary extends Employee {\n   private double salary;   // Annual salary\n\n   public double computePay() {\n      System.out.println( Computing salary pay for   + getName());\n      return salary/52;\n   }\n   // Remainder of class definition\n}", 
            "title": "Abstract Methods"
        }, 
        {
            "location": "/oop_abstraction/#related-readings", 
            "text": "\"Java Abstraction\".  www.tutorialspoint.com . N.p., 2016. Web. 10 Dec. 2016.", 
            "title": "Related Readings"
        }, 
        {
            "location": "/io/", 
            "text": "The java.io package contains nearly every class you might ever need to perform input and output (I/O) in Java. All these streams represent an input source and an output destination. The stream in the java.io package supports many data such as primitives, object, localized characters, etc.\n\n\nStream\n\n\nA stream can be defined as a sequence of data. There are two kinds of Streams \u2212\n\n\n\n\nInPutStream \u2212 The InputStream is used to read data from a source.\n\n\nOutPutStream \u2212 The OutputStream is used for writing data to a destination.\n\n\n\n\n\n\nJava provides strong but flexible support for I/O related to files and networks but this tutorial covers very basic functionality related to streams and I/O. We will see the most commonly used examples one by one\n\n\nByte Streams\n\n\nJava byte streams are used to perform input and output of 8-bit bytes. Though there are many classes related to byte streams but the most frequently used classes are, \nFileInputStream\n and \nFileOutputStream\n. Following is an example which makes use of these two classes to copy an input file into an output file\n\n\nExample\n\n\nimport java.io.*;\npublic class CopyFile {\n\n   public static void main(String args[]) throws IOException {\n      FileInputStream in = null;\n      FileOutputStream out = null;\n\n      try {\n         in = new FileInputStream(\ninput.txt\n);\n         out = new FileOutputStream(\noutput.txt\n);\n\n         int c;\n         while ((c = in.read()) != -1) {\n            out.write(c);\n         }\n      }finally {\n         if (in != null) {\n            in.close();\n         }\n         if (out != null) {\n            out.close();\n         }\n      }\n   }\n}\n\n\n\n\nNow let's have a file input.txt with the following content\n\n\nThis is test for copy file.\n\n\n\n\nAs a next step, compile the above program and execute it, which will result in creating output.txt file with the same content as we have in input.txt. So let's put the above code in CopyFile.java file and do the following\n\n\n$javac CopyFile.java\n$java CopyFile\n\n\n\n\nCharacter Streams\n\n\nJava Byte streams are used to perform input and output of 8-bit bytes, whereas Java Character streams are used to perform input and output for 16-bit unicode. Though there are many classes related to character streams but the most frequently used classes are, FileReader and FileWriter. Though internally FileReader uses FileInputStream and FileWriter uses FileOutputStream but here the major difference is that FileReader reads two bytes at a time and FileWriter writes two bytes at a time.\n\n\nWe can re-write the above example, which makes the use of these two classes to copy an input file (having unicode characters) into an output file\n\n\nExample\n\n\nimport java.io.*;\npublic class CopyFile {\n\n   public static void main(String args[]) throws IOException {\n      FileReader in = null;\n      FileWriter out = null;\n\n      try {\n         in = new FileReader(\ninput.txt\n);\n         out = new FileWriter(\noutput.txt\n);\n\n         int c;\n         while ((c = in.read()) != -1) {\n            out.write(c);\n         }\n      }finally {\n         if (in != null) {\n            in.close();\n         }\n         if (out != null) {\n            out.close();\n         }\n      }\n   }\n}\n\n\n\n\nNow let's have a file input.txt with the following content\n\n\nThis is test for copy file.\n\n\n\n\nAs a next step, compile the above program and execute it, which will result in creating output.txt file with the same content as we have in input.txt. So let's put the above code in CopyFile.java file and do the following\n\n\n$javac CopyFile.java\n$java CopyFile\n\n\n\n\nStandard Streams\n\n\nAll the programming languages provide support for standard I/O where the user's program can take input from a keyboard and then produce an output on the computer screen. If you are aware of C or C++ programming languages, then you must be aware of three standard devices STDIN, STDOUT and STDERR. Similarly, Java provides the following three standard streams \u2212\n\n\n\n\nStandard Input\n \u2212 This is used to feed the data to user's program and usually a keyboard is used as standard input stream and represented as System.in.\n\n\nStandard Output\n \u2212 This is used to output the data produced by the user's program and usually a computer screen is used for standard output stream and represented as System.out.\n\n\nStandard Error\n \u2212 This is used to output the error data produced by the user's program and usually a computer screen is used for standard error stream and represented as System.err.\n\n\n\n\nFollowing is a simple program, which creates InputStreamReader to read standard input stream until the user types a \"q\"\n\n\nExample\n\n\nimport java.io.*;\npublic class ReadConsole {\n\n   public static void main(String args[]) throws IOException {\n      InputStreamReader cin = null;\n\n      try {\n         cin = new InputStreamReader(System.in);\n         System.out.println(\nEnter characters, 'q' to quit.\n);\n         char c;\n         do {\n            c = (char) cin.read();\n            System.out.print(c);\n         } while(c != 'q');\n      }finally {\n         if (cin != null) {\n            cin.close();\n         }\n      }\n   }\n}\n\n\n\n\nLet's keep the above code in ReadConsole.java file and try to compile and execute it as shown in the following program. This program continues to read and output the same character until we press 'q'\n\n\n$javac ReadConsole.java\n$java ReadConsole\nEnter characters, 'q' to quit.\n1\n1\ne\ne\nq\nq\n\n\n\n\nReading and Writing Files\n\n\nAs described earlier, a stream can be defined as a sequence of data. The InputStream is used to read data from a source and the OutputStream is used for writing data to a destination.\n\n\nHere is a hierarchy of classes to deal with Input and Output streams.\n\n\n\n\nThe two important streams are FileInputStream and FileOutputStream, which would be discussed in this tutorial.\n\n\nFileInputStream\n\n\nThis stream is used for reading data from the files. Objects can be created using the keyword new and there are several types of constructors available.\n\n\nFollowing constructor takes a file name as a string to create an input stream object to read the file\n\n\nInputStream f = new FileInputStream(\nC:/java/hello\n);\n\n\n\n\nFollowing constructor takes a file object to create an input stream object to read the file. First we create a file object using File() method as follows\n\n\nFile f = new File(\nC:/java/hello\n);\nInputStream f = new FileInputStream(f);\n\n\n\n\nOnce you have InputStream object in hand, then there is a list of helper methods which can be used to read to stream or to do other operations on the stream.\n\n\n\n\n\n\n\n\n\n\nMethod \n Description\n\n\n\n\n\n\n1\n\n\n\n\npublic void close() throws IOException{}\n\n\nThis method closes the file output stream. Releases any system resources associated with the file. Throws an IOException.\n\n\n\n\n\n\n\n\n2\n\n\n\n\nprotected void finalize()throws IOException {}\n\n\nThis method cleans up the connection to the file. Ensures that the close method of this file output stream is called when there are no more references to this stream. Throws an IOException.\n\n\n\n\n\n\n\n\n3\n\n\n\n\npublic int read(int r)throws IOException{}\n\n\nThis method reads the specified byte of data from the InputStream. Returns an int. Returns the next byte of data and -1 will be returned if it's the end of the file.\n\n\n\n\n\n\n\n\n4\n\n\n\n\npublic int read(byte[] r) throws IOException{}\n\n\nThis method reads r.length bytes from the input stream into an array. Returns the total number of bytes read. If it is the end of the file, -1 will be returned.\n\n\n\n\n\n\n\n\n5\n\n\n\n\npublic int available() throws IOException{}\n\n\nGives the number of bytes that can be read from this file input stream. Returns an int.\n\n\n\n\n\n\n\n\n\n\n\nThere are other important input streams available, for more detail you can refer to the following links \u2212\n\n\n\n\nByteArrayInputStream\n\n\nDataInputStream\n\n\n\n\nFileOutputStream\n\n\nFileOutputStream is used to create a file and write data into it. The stream would create a file, if it doesn't already exist, before opening it for output.\n\n\nHere are two constructors which can be used to create a FileOutputStream object.\n\n\nFollowing constructor takes a file name as a string to create an input stream object to write the file\n\n\nOutputStream f = new FileOutputStream(\nC:/java/hello\n)\n\n\n\n\nFollowing constructor takes a file object to create an output stream object to write the file. First, we create a file object using File() method as follows\n\n\nFile f = new File(\nC:/java/hello\n);\nOutputStream f = new FileOutputStream(f);\n\n\n\n\nOnce you have \nOutputStream\n object in hand, then there is a list of helper methods, which can be used to write to stream or to do other operations on the stream.\n\n\n\n\n\n\n\n\n\n\nMethod \n Description\n\n\n\n\n\n\n1\n\n\n\n\npublic void close() throws IOException{}\n\n\nThis method closes the file output stream. Releases any system resources associated with the file. Throws an IOException.\n\n\n\n\n\n\n\n\n2\n\n\n\n\nprotected void finalize()throws IOException {}\n\n\nThis method cleans up the connection to the file. Ensures that the close method of this file output stream is called when there are no more references to this stream. Throws an IOException.\n\n\n\n\n\n\n\n\n3\n\n\n\n\npublic void write(int w)throws IOException{}\n\n\nThis methods writes the specified byte to the output stream.\n\n\n\n\n\n\n\n\n4\n\n\n\n\npublic void write(byte[] w)\n\n\nWrites w.length bytes from the mentioned byte array to the OutputStream.\n\n\n\n\n\n\n\n\n\n\n\nThere are other important output streams available, for more detail you can refer to the following links \u2212\n\n\n\n\nByteArrayOutputStream\n\n\nDataOutputStream\n\n\n\n\nExample\n\n\nFollowing is the example to demonstrate InputStream and OutputStream\n\n\nimport java.io.*;\npublic class fileStreamTest {\n\n   public static void main(String args[]) {\n\n      try {\n         byte bWrite [] = {11,21,3,40,5};\n         OutputStream os = new FileOutputStream(\ntest.txt\n);\n         for(int x = 0; x \n bWrite.length ; x++) {\n            os.write( bWrite[x] );   // writes the bytes\n         }\n         os.close();\n\n         InputStream is = new FileInputStream(\ntest.txt\n);\n         int size = is.available();\n\n         for(int i = 0; i \n size; i++) {\n            System.out.print((char)is.read() + \n  \n);\n         }\n         is.close();\n      }catch(IOException e) {\n         System.out.print(\nException\n);\n      }\n   }\n}\n\n\n\n\nThe above code would create file test.txt and would write given numbers in binary format. Same would be the output on the stdout screen.\n\n\nFile Navigation and I/O\n\n\nThere are several other classes that we would be going through to get to know the basics of File Navigation and I/O.\n\n\n\n\nFile Class\n\n\nFileReader Class\n\n\nFileWriter Class\n\n\n\n\nDirectories in Java\n\n\nA directory is a File which can contain a list of other files and directories. You use \nFile\n object to create directories, to list down files available in a directory. For complete detail, check a list of all the methods which you can call on File object and what are related to directories.\n\n\nCreating Directories\n\n\nThere are two useful File utility methods, which can be used to create directories\n\n\nThe mkdir( ) method creates a directory, returning true on success and false on failure. Failure indicates that the path specified in the File object already exists, or that the directory cannot be created because the entire path does not exist yet.\n\n\nThe mkdirs() method creates both a directory and all the parents of the directory.\n\n\nFollowing example creates \"/tmp/user/java/bin\" directory\n\n\nExample\n\n\nimport java.io.File;\npublic class CreateDir {\n\n   public static void main(String args[]) {\n      String dirname = \n/tmp/user/java/bin\n;\n      File d = new File(dirname);\n\n      // Create directory now.\n      d.mkdirs();\n   }\n}\n\n\n\n\nCompile and execute the above code to create \"/tmp/user/java/bin\".\n\n\nNote\n \u2212 Java automatically takes care of path separators on UNIX and Windows as per conventions. If you use a forward slash (/) on a Windows version of Java, the path will still resolve correctly.\n\n\nListing Directories\n\n\nYou can use \nlist( )\n method provided by \nFile\n object to list down all the files and directories available in a directory as follows\n\n\nExample\n\n\nimport java.io.File;\npublic class ReadDir {\n\n   public static void main(String[] args) {\n      File file = null;\n      String[] paths;\n\n      try {\n         // create new file object\n         file = new File(\n/tmp\n);\n\n         // array of files and directory\n         paths = file.list();\n\n         // for each name in the path array\n         for(String path:paths) {\n            // prints filename and directory name\n            System.out.println(path);\n         }\n      }catch(Exception e) {\n         // if any error occurs\n         e.printStackTrace();\n      }\n   }\n}\n\n\n\n\nThis will produce the following result based on the directories and files available in your \n/tmp\n directory\n\n\ntest1.txt\ntest2.txt\nReadDir.java\nReadDir.class", 
            "title": "Files & IO"
        }, 
        {
            "location": "/io/#stream", 
            "text": "A stream can be defined as a sequence of data. There are two kinds of Streams \u2212   InPutStream \u2212 The InputStream is used to read data from a source.  OutPutStream \u2212 The OutputStream is used for writing data to a destination.    Java provides strong but flexible support for I/O related to files and networks but this tutorial covers very basic functionality related to streams and I/O. We will see the most commonly used examples one by one", 
            "title": "Stream"
        }, 
        {
            "location": "/io/#byte-streams", 
            "text": "Java byte streams are used to perform input and output of 8-bit bytes. Though there are many classes related to byte streams but the most frequently used classes are,  FileInputStream  and  FileOutputStream . Following is an example which makes use of these two classes to copy an input file into an output file  Example  import java.io.*;\npublic class CopyFile {\n\n   public static void main(String args[]) throws IOException {\n      FileInputStream in = null;\n      FileOutputStream out = null;\n\n      try {\n         in = new FileInputStream( input.txt );\n         out = new FileOutputStream( output.txt );\n\n         int c;\n         while ((c = in.read()) != -1) {\n            out.write(c);\n         }\n      }finally {\n         if (in != null) {\n            in.close();\n         }\n         if (out != null) {\n            out.close();\n         }\n      }\n   }\n}  Now let's have a file input.txt with the following content  This is test for copy file.  As a next step, compile the above program and execute it, which will result in creating output.txt file with the same content as we have in input.txt. So let's put the above code in CopyFile.java file and do the following  $javac CopyFile.java\n$java CopyFile", 
            "title": "Byte Streams"
        }, 
        {
            "location": "/io/#character-streams", 
            "text": "Java Byte streams are used to perform input and output of 8-bit bytes, whereas Java Character streams are used to perform input and output for 16-bit unicode. Though there are many classes related to character streams but the most frequently used classes are, FileReader and FileWriter. Though internally FileReader uses FileInputStream and FileWriter uses FileOutputStream but here the major difference is that FileReader reads two bytes at a time and FileWriter writes two bytes at a time.  We can re-write the above example, which makes the use of these two classes to copy an input file (having unicode characters) into an output file  Example  import java.io.*;\npublic class CopyFile {\n\n   public static void main(String args[]) throws IOException {\n      FileReader in = null;\n      FileWriter out = null;\n\n      try {\n         in = new FileReader( input.txt );\n         out = new FileWriter( output.txt );\n\n         int c;\n         while ((c = in.read()) != -1) {\n            out.write(c);\n         }\n      }finally {\n         if (in != null) {\n            in.close();\n         }\n         if (out != null) {\n            out.close();\n         }\n      }\n   }\n}  Now let's have a file input.txt with the following content  This is test for copy file.  As a next step, compile the above program and execute it, which will result in creating output.txt file with the same content as we have in input.txt. So let's put the above code in CopyFile.java file and do the following  $javac CopyFile.java\n$java CopyFile", 
            "title": "Character Streams"
        }, 
        {
            "location": "/io/#standard-streams", 
            "text": "All the programming languages provide support for standard I/O where the user's program can take input from a keyboard and then produce an output on the computer screen. If you are aware of C or C++ programming languages, then you must be aware of three standard devices STDIN, STDOUT and STDERR. Similarly, Java provides the following three standard streams \u2212   Standard Input  \u2212 This is used to feed the data to user's program and usually a keyboard is used as standard input stream and represented as System.in.  Standard Output  \u2212 This is used to output the data produced by the user's program and usually a computer screen is used for standard output stream and represented as System.out.  Standard Error  \u2212 This is used to output the error data produced by the user's program and usually a computer screen is used for standard error stream and represented as System.err.   Following is a simple program, which creates InputStreamReader to read standard input stream until the user types a \"q\"  Example  import java.io.*;\npublic class ReadConsole {\n\n   public static void main(String args[]) throws IOException {\n      InputStreamReader cin = null;\n\n      try {\n         cin = new InputStreamReader(System.in);\n         System.out.println( Enter characters, 'q' to quit. );\n         char c;\n         do {\n            c = (char) cin.read();\n            System.out.print(c);\n         } while(c != 'q');\n      }finally {\n         if (cin != null) {\n            cin.close();\n         }\n      }\n   }\n}  Let's keep the above code in ReadConsole.java file and try to compile and execute it as shown in the following program. This program continues to read and output the same character until we press 'q'  $javac ReadConsole.java\n$java ReadConsole\nEnter characters, 'q' to quit.\n1\n1\ne\ne\nq\nq", 
            "title": "Standard Streams"
        }, 
        {
            "location": "/io/#reading-and-writing-files", 
            "text": "As described earlier, a stream can be defined as a sequence of data. The InputStream is used to read data from a source and the OutputStream is used for writing data to a destination.  Here is a hierarchy of classes to deal with Input and Output streams.   The two important streams are FileInputStream and FileOutputStream, which would be discussed in this tutorial.", 
            "title": "Reading and Writing Files"
        }, 
        {
            "location": "/io/#fileinputstream", 
            "text": "This stream is used for reading data from the files. Objects can be created using the keyword new and there are several types of constructors available.  Following constructor takes a file name as a string to create an input stream object to read the file  InputStream f = new FileInputStream( C:/java/hello );  Following constructor takes a file object to create an input stream object to read the file. First we create a file object using File() method as follows  File f = new File( C:/java/hello );\nInputStream f = new FileInputStream(f);  Once you have InputStream object in hand, then there is a list of helper methods which can be used to read to stream or to do other operations on the stream.      Method   Description    1   public void close() throws IOException{}  This method closes the file output stream. Releases any system resources associated with the file. Throws an IOException.     2   protected void finalize()throws IOException {}  This method cleans up the connection to the file. Ensures that the close method of this file output stream is called when there are no more references to this stream. Throws an IOException.     3   public int read(int r)throws IOException{}  This method reads the specified byte of data from the InputStream. Returns an int. Returns the next byte of data and -1 will be returned if it's the end of the file.     4   public int read(byte[] r) throws IOException{}  This method reads r.length bytes from the input stream into an array. Returns the total number of bytes read. If it is the end of the file, -1 will be returned.     5   public int available() throws IOException{}  Gives the number of bytes that can be read from this file input stream. Returns an int.      There are other important input streams available, for more detail you can refer to the following links \u2212   ByteArrayInputStream  DataInputStream", 
            "title": "FileInputStream"
        }, 
        {
            "location": "/io/#fileoutputstream", 
            "text": "FileOutputStream is used to create a file and write data into it. The stream would create a file, if it doesn't already exist, before opening it for output.  Here are two constructors which can be used to create a FileOutputStream object.  Following constructor takes a file name as a string to create an input stream object to write the file  OutputStream f = new FileOutputStream( C:/java/hello )  Following constructor takes a file object to create an output stream object to write the file. First, we create a file object using File() method as follows  File f = new File( C:/java/hello );\nOutputStream f = new FileOutputStream(f);  Once you have  OutputStream  object in hand, then there is a list of helper methods, which can be used to write to stream or to do other operations on the stream.      Method   Description    1   public void close() throws IOException{}  This method closes the file output stream. Releases any system resources associated with the file. Throws an IOException.     2   protected void finalize()throws IOException {}  This method cleans up the connection to the file. Ensures that the close method of this file output stream is called when there are no more references to this stream. Throws an IOException.     3   public void write(int w)throws IOException{}  This methods writes the specified byte to the output stream.     4   public void write(byte[] w)  Writes w.length bytes from the mentioned byte array to the OutputStream.      There are other important output streams available, for more detail you can refer to the following links \u2212   ByteArrayOutputStream  DataOutputStream   Example  Following is the example to demonstrate InputStream and OutputStream  import java.io.*;\npublic class fileStreamTest {\n\n   public static void main(String args[]) {\n\n      try {\n         byte bWrite [] = {11,21,3,40,5};\n         OutputStream os = new FileOutputStream( test.txt );\n         for(int x = 0; x   bWrite.length ; x++) {\n            os.write( bWrite[x] );   // writes the bytes\n         }\n         os.close();\n\n         InputStream is = new FileInputStream( test.txt );\n         int size = is.available();\n\n         for(int i = 0; i   size; i++) {\n            System.out.print((char)is.read() +     );\n         }\n         is.close();\n      }catch(IOException e) {\n         System.out.print( Exception );\n      }\n   }\n}  The above code would create file test.txt and would write given numbers in binary format. Same would be the output on the stdout screen.", 
            "title": "FileOutputStream"
        }, 
        {
            "location": "/io/#file-navigation-and-io", 
            "text": "There are several other classes that we would be going through to get to know the basics of File Navigation and I/O.   File Class  FileReader Class  FileWriter Class", 
            "title": "File Navigation and I/O"
        }, 
        {
            "location": "/io/#directories-in-java", 
            "text": "A directory is a File which can contain a list of other files and directories. You use  File  object to create directories, to list down files available in a directory. For complete detail, check a list of all the methods which you can call on File object and what are related to directories.", 
            "title": "Directories in Java"
        }, 
        {
            "location": "/io/#creating-directories", 
            "text": "There are two useful File utility methods, which can be used to create directories  The mkdir( ) method creates a directory, returning true on success and false on failure. Failure indicates that the path specified in the File object already exists, or that the directory cannot be created because the entire path does not exist yet.  The mkdirs() method creates both a directory and all the parents of the directory.  Following example creates \"/tmp/user/java/bin\" directory  Example  import java.io.File;\npublic class CreateDir {\n\n   public static void main(String args[]) {\n      String dirname =  /tmp/user/java/bin ;\n      File d = new File(dirname);\n\n      // Create directory now.\n      d.mkdirs();\n   }\n}  Compile and execute the above code to create \"/tmp/user/java/bin\".  Note  \u2212 Java automatically takes care of path separators on UNIX and Windows as per conventions. If you use a forward slash (/) on a Windows version of Java, the path will still resolve correctly.", 
            "title": "Creating Directories"
        }, 
        {
            "location": "/io/#listing-directories", 
            "text": "You can use  list( )  method provided by  File  object to list down all the files and directories available in a directory as follows  Example  import java.io.File;\npublic class ReadDir {\n\n   public static void main(String[] args) {\n      File file = null;\n      String[] paths;\n\n      try {\n         // create new file object\n         file = new File( /tmp );\n\n         // array of files and directory\n         paths = file.list();\n\n         // for each name in the path array\n         for(String path:paths) {\n            // prints filename and directory name\n            System.out.println(path);\n         }\n      }catch(Exception e) {\n         // if any error occurs\n         e.printStackTrace();\n      }\n   }\n}  This will produce the following result based on the directories and files available in your  /tmp  directory  test1.txt\ntest2.txt\nReadDir.java\nReadDir.class", 
            "title": "Listing Directories"
        }, 
        {
            "location": "/error_handling/", 
            "text": "An exception (or exceptional event) is a problem that arises during the execution of a program. When an \nException\n occurs the normal flow of the program is disrupted and the program/Application terminates abnormally, which is not recommended, therefore, these exceptions are to be handled.\n\n\nAn exception can occur for many different reasons. Following are some scenarios where an exception occurs.\n\n\n\n\nA user has entered an invalid data.\n\n\nA file that needs to be opened cannot be found.\n\n\nA network connection has been lost in the middle of communications or the JVM has run out of memory.\n\n\n\n\nSome of these exceptions are caused by user error, others by programmer error, and others by physical resources that have failed in some manner.\n\n\nBased on these, we have three categories of Exceptions. You need to understand them to know how exception handling works in Java.\n\n\nType of exceptions\n\n\nChecked Exception\n\n\nA checked exception is an exception that occurs at the compile time, these are also called as compile time exceptions. These exceptions cannot simply be ignored at the time of compilation, the programmer should take care of (handle) these exceptions.\n\n\nFor example, if you use FileReader class in your program to read data from a file, if the file specified in its constructor doesn't exist, then a FileNotFoundException occurs, and the compiler prompts the programmer to handle the exception.\n\n\nimport java.io.File;\nimport java.io.FileReader;\n\npublic class FilenotFound_Demo {\n\n   public static void main(String args[]) {     \n      File file = new File(\nE://file.txt\n);\n      FileReader fr = new FileReader(file); \n   }\n}\n\n\n\n\nIf you try to compile the above program, you will get the following exceptions.\n\n\nC:\\\njavac FilenotFound_Demo.java\nFilenotFound_Demo.java:8: error: unreported exception FileNotFoundException; must be caught or declared to be thrown\n      FileReader fr = new FileReader(file);\n                      ^\n1 error\n\n\n\n\nNote \u2212 Since the methods \nread()\n and \nclose()\n of FileReader class throws IOException, you can observe that the compiler notifies to handle IOException, along with FileNotFoundException.\n\n\nUnchecked exceptions\n\n\nAn unchecked exception is an exception that occurs at the time of execution. These are also called as \nRuntime Exceptions\n. These include programming bugs, such as logic errors or improper use of an API. Runtime exceptions are ignored at the time of compilation.\n\n\nFor example, if you have declared an array of size 5 in your program, and trying to call the 6th element of the array then an \nArrayIndexOutOfBoundsExceptionexception\n occurs.\n\n\npublic class Unchecked_Demo {\n\n   public static void main(String args[]) {\n      int num[] = {1, 2, 3, 4};\n      System.out.println(num[5]);\n   }\n}\n\n\n\n\nIf you compile and execute the above program, you will get the following exception.\n\n\nException in thread \nmain\n java.lang.ArrayIndexOutOfBoundsException: 5\n    at Exceptions.Unchecked_Demo.main(Unchecked_Demo.java:8)\n\n\n\n\nErrors\n\n\nThese are not exceptions at all, but problems that arise beyond the control of the user or the programmer. Errors are typically ignored in your code because you can rarely do anything about an error. For example, if a stack overflow occurs, an error will arise. They are also ignored at the time of compilation.\n\n\nException Hierarchy\n\n\nAll exception classes are subtypes of the java.lang.Exception class. The exception class is a subclass of the Throwable class. Other than the exception class there is another subclass called Error which is derived from the Throwable class.\n\n\nErrors are abnormal conditions that happen in case of severe failures, these are not handled by the Java programs. Errors are generated to indicate errors generated by the runtime environment. Example: JVM is out of memory. Normally, programs cannot recover from errors.\n\n\nThe Exception class has two main subclasses: IOException class and RuntimeException Class.\n\n\n\n\nFollowing is a list of most common checked and unchecked Java's Built-in Exceptions\n\n\nExceptions Methods\n\n\nFollowing is the list of important methods available in the Throwable class.\n\n\n\n\n\n\n\n\n1\n\n\npublic String getMessage()\nReturns a detailed message about the exception that has occurred. This message is initialized in the Throwable constructor.\n\n\n\n\n\n\n2\n\n\npublic Throwable getCause()\nReturns the cause of the exception as represented by a Throwable object.\n\n\n\n\n\n\n3\n\n\npublic String toString()\nReturns the name of the class concatenated with the result of getMessage().\n\n\n\n\n\n\n4\n\n\npublic void printStackTrace()\nPrints the result of toString() along with the stack trace to System.err, the error output stream.\n\n\n\n\n\n\n5\n\n\npublic StackTraceElement [] getStackTrace()\nReturns an array containing each element on the stack trace. The element at index 0 represents the top of the call stack, and the last element in the array represents the method at the bottom of the call stack.\n\n\n\n\n\n\n6\n\n\npublic Throwable fillInStackTrace()\nFills the stack trace of this Throwable object with the current stack trace, adding to any previous information in the stack trace.\n\n\n\n\n\n\n\n\n\nCatching Exceptions\n\n\nA method catches an exception using a combination of the \ntry\n and \ncatch\n keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following\n\n\nSyntax\n\n\ntry {\n   // Protected code\n}catch(ExceptionName e1) {\n   // Catch block\n}\n\n\n\n\nThe code which is prone to exceptions is placed in the try block. When an exception occurs, that exception occurred is handled by catch block associated with it. Every try block should be immediately followed either by a catch block or finally block.\n\n\nA catch statement involves declaring the type of exception you are trying to catch. If an exception occurs in protected code, the catch block (or blocks) that follows the try is checked. If the type of exception that occurred is listed in a catch block, the exception is passed to the catch block much as an argument is passed into a method parameter.\n\n\nExample\n\n\nThe following is an array declared with 2 elements. Then the code tries to access the 3rd element of the array which throws an exception.\n\n\n// File Name : ExcepTest.java\nimport java.io.*;\n\npublic class ExcepTest {\n\n   public static void main(String args[]) {\n      try {\n         int a[] = new int[2];\n         System.out.println(\nAccess element three :\n + a[3]);\n      }catch(ArrayIndexOutOfBoundsException e) {\n         System.out.println(\nException thrown  :\n + e);\n      }\n      System.out.println(\nOut of the block\n);\n   }\n}\n\n\n\n\nThis will produce the following result\n\n\nException thrown  :java.lang.ArrayIndexOutOfBoundsException: 3\nOut of the block\n\n\n\n\nMultiple Catch Blocks\n\n\nA try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following\n\n\ntry {\n   // Protected code\n}catch(ExceptionType1 e1) {\n   // Catch block\n}catch(ExceptionType2 e2) {\n   // Catch block\n}catch(ExceptionType3 e3) {\n   // Catch block\n}\n\n\n\n\nThe previous statements demonstrate three catch blocks, but you can have any number of them after a single try. If an exception occurs in the protected code, the exception is thrown to the first catch block in the list. If the data type of the exception thrown matches ExceptionType1, it gets caught there. If not, the exception passes down to the second catch statement. This continues until the exception either is caught or falls through all catches, in which case the current method stops execution and the exception is thrown down to the previous method on the call stack.\n\n\nExample\n\n\nHere is code segment showing how to use multiple try/catch statements.\n\n\ntry {\n   file = new FileInputStream(fileName);\n   x = (byte) file.read();\n}catch(IOException i) {\n   i.printStackTrace();\n   return -1;\n}catch(FileNotFoundException f) // Not valid! {\n   f.printStackTrace();\n   return -1;\n}\n\n\n\n\nCatching Multiple Type of Exceptions\n\n\nSince Java 7, you can handle more than one exception using a single catch block, this feature simplifies the code. Here is how you would do it\n\n\ncatch (IOException|FileNotFoundException ex) {\n   logger.log(ex);\n   throw ex;\n\n\n\n\nThe Throws/Throw Keywords\n\n\nIf a method does not handle a checked exception, the method must declare it using the throws keyword. The throws keyword appears at the end of a method's signature.\n\n\nYou can throw an exception, either a newly instantiated one or an exception that you just caught, by using the throw keyword.\n\n\nTry to understand the difference between throws and throw keywords, throws is used to postpone the handling of a checked exception and throw is used to invoke an exception explicitly.\n\n\nThe following method declares that it throws a RemoteException \n\n\nimport java.io.*;\npublic class className {\n\n   public void deposit(double amount) throws RemoteException {\n      // Method implementation\n      throw new RemoteException();\n   }\n   // Remainder of class definition\n}\n\n\n\n\nA method can declare that it throws more than one exception, in which case the exceptions are declared in a list separated by commas. For example, the following method declares that it throws a RemoteException and an InsufficientFundsException\n\n\nimport java.io.*;\npublic class className {\n\n   public void withdraw(double amount) throws RemoteException, \n      InsufficientFundsException {\n      // Method implementation\n   }\n   // Remainder of class definition\n}\n\n\n\n\nThe Finally Block\n\n\nThe finally block follows a try block or a catch block. A finally block of code always executes, irrespective of occurrence of an Exception.\n\n\nUsing a finally block allows you to run any cleanup-type statements that you want to execute, no matter what happens in the protected code.\n\n\nA finally block appears at the end of the catch blocks and has the following syntax\n\n\nSyntax\n\n\ntry {\n   // Protected code\n}catch(ExceptionType1 e1) {\n   // Catch block\n}catch(ExceptionType2 e2) {\n   // Catch block\n}catch(ExceptionType3 e3) {\n   // Catch block\n}finally {\n   // The finally block always executes.\n}\n\n\n\n\n\nExample\n\n\npublic class ExcepTest {\n\n   public static void main(String args[]) {\n      int a[] = new int[2];\n      try {\n         System.out.println(\nAccess element three :\n + a[3]);\n      }catch(ArrayIndexOutOfBoundsException e) {\n         System.out.println(\nException thrown  :\n + e);\n      }finally {\n         a[0] = 6;\n         System.out.println(\nFirst element value: \n + a[0]);\n         System.out.println(\nThe finally statement is executed\n);\n      }\n   }\n}\n\n\n\n\nThis will produce the following result \n\n\nException thrown  :java.lang.ArrayIndexOutOfBoundsException: 3\nFirst element value: 6\nThe finally statement is executed\n\n\n\n\nNote the following\n\n\n\n\nA catch clause cannot exist without a try statement.\n\n\nIt is not compulsory to have finally clauses whenever a try/catch block is present.\n\n\nThe try block cannot be present without either catch clause or finally clause.\n\n\nAny code cannot be present in between the try, catch, finally blocks.\n\n\n\n\nThe try-with-resources\n\n\nGenerally, when we use any resources like streams, connections, etc. we have to close them explicitly using finally block. In the following program, we are reading data from a file using FileReader and we are closing it using finally block.\n\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class ReadData_Demo {\n\n   public static void main(String args[]) {\n      FileReader fr = null;     \n      try {\n         File file = new File(\nfile.txt\n);\n         fr = new FileReader(file); char [] a = new char[50];\n         fr.read(a);   // reads the content to the array\n         for(char c : a)\n         System.out.print(c);   // prints the characters one by one\n      }catch(IOException e) {\n         e.printStackTrace();\n      }finally {\n         try {\n            fr.close();\n         }catch(IOException ex) {       \n            ex.printStackTrace();\n         }\n      }\n   }\n}\n\n\n\n\ntry-with-resources, also referred as automatic resource management, is a new exception handling mechanism that was introduced in Java 7, which automatically closes the resources used within the try catch block.\n\n\nTo use this statement, you simply need to declare the required resources within the parenthesis, and the created resource will be closed automatically at the end of the block. Following is the syntax of try-with-resources statement.\n\n\nSyntax\n\n\ntry(FileReader fr = new FileReader(\nfile path\n)) {\n   // use the resource\n   }catch() {\n      // body of catch \n   }\n}\n\n\n\n\nFollowing is the program that reads the data in a file using try-with-resources statement.\n\n\nExample\n\n\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Try_withDemo {\n\n   public static void main(String args[]) {\n      try(FileReader fr = new FileReader(\nE://file.txt\n)) {\n         char [] a = new char[50];\n         fr.read(a);   // reads the contentto the array\n         for(char c : a)\n         System.out.print(c);   // prints the characters one by one\n      }catch(IOException e) {\n         e.printStackTrace();\n      }\n   }\n}\n\n\n\n\nFollowing points are to be kept in mind while working with try-with-resources statement.\n\n\n\n\nTo use a class with try-with-resources statement it should implement AutoCloseable interface and the close() method of it gets invoked automatically at runtime.\n\n\nYou can declare more than one class in try-with-resources statement.\n\n\nWhile you declare multiple classes in the try block of try-with-resources statement these classes are closed in reverse order.\n\n\nExcept the declaration of resources within the parenthesis everything is the same as normal try/catch block of a try block.\n\n\nThe resource declared in try gets instantiated just before the start of the try-block.\n\n\nThe resource declared at the try block is implicitly declared as final.\n\n\n\n\nUser-defined Exceptions\n\n\nYou can create your own exceptions in Java. Keep the following points in mind when writing your own exception classes \u2212\n\n\n\n\nAll exceptions must be a child of Throwable.\n\n\nIf you want to write a checked exception that is automatically enforced by the Handle or Declare Rule, you need to extend the Exception class.\n\n\nIf you want to write a runtime exception, you need to extend the RuntimeException class.\n\n\n\n\nWe can define our own Exception class as below\n\n\nclass MyException extends Exception {\n}\n\n\n\n\nYou just need to extend the predefined Exception class to create your own Exception. These are considered to be checked exceptions. The following InsufficientFundsException class is a user-defined exception that extends the Exception class, making it a checked exception. An exception class is like any other class, containing useful fields and methods.\n\n\nExample\n\n\n// File Name InsufficientFundsException.java\nimport java.io.*;\n\npublic class InsufficientFundsException extends Exception {\n   private double amount;\n\n   public InsufficientFundsException(double amount) {\n      this.amount = amount;\n   }\n\n   public double getAmount() {\n      return amount;\n   }\n}\n\n\n\n\nTo demonstrate using our user-defined exception, the following CheckingAccount class contains a withdraw() method that throws an InsufficientFundsException.\n\n\n// File Name CheckingAccount.java\nimport java.io.*;\n\npublic class CheckingAccount {\n   private double balance;\n   private int number;\n\n   public CheckingAccount(int number) {\n      this.number = number;\n   }\n\n   public void deposit(double amount) {\n      balance += amount;\n   }\n\n   public void withdraw(double amount) throws InsufficientFundsException {\n      if(amount \n= balance) {\n         balance -= amount;\n      }else {\n         double needs = amount - balance;\n         throw new InsufficientFundsException(needs);\n      }\n   }\n\n   public double getBalance() {\n      return balance;\n   }\n\n   public int getNumber() {\n      return number;\n   }\n}\n\n\n\n\nThe following BankDemo program demonstrates invoking the deposit() and withdraw() methods of CheckingAccount.\n\n\n// File Name BankDemo.java\npublic class BankDemo {\n\n   public static void main(String [] args) {\n      CheckingAccount c = new CheckingAccount(101);\n      System.out.println(\nDepositing $500...\n);\n      c.deposit(500.00);\n\n      try {\n         System.out.println(\n\\nWithdrawing $100...\n);\n         c.withdraw(100.00);\n         System.out.println(\n\\nWithdrawing $600...\n);\n         c.withdraw(600.00);\n      }catch(InsufficientFundsException e) {\n         System.out.println(\nSorry, but you are short $\n + e.getAmount());\n         e.printStackTrace();\n      }\n   }\n}\n\n\n\n\nCompile all the above three files and run BankDemo. This will produce the following result \n\n\nOutput\n\n\nDepositing $500...\n\nWithdrawing $100...\n\nWithdrawing $600...\nSorry, but you are short $200.0\nInsufficientFundsException\n         at CheckingAccount.withdraw(CheckingAccount.java:25)\n         at BankDemo.main(BankDemo.java:13)\n\n\n\n\nCommon Exceptions\n\n\nIn Java, it is possible to define two catergories of Exceptions and Errors.\n\n\n\n\nJVM Exceptions \u2212 These are exceptions/errors that are exclusively or logically thrown by the JVM. Examples: NullPointerException, ArrayIndexOutOfBoundsException, ClassCastException.\n\n\nProgrammatic Exceptions \u2212 These exceptions are thrown explicitly by the application or the API programmers. Examples: IllegalArgumentException, IllegalStateException.\n\n\n\n\nRelated Readings\n\n\n\n\n\"Java Exceptions\". 2016. \nwww.Tutorialspoint.Com\n. https://www.tutorialspoint.com/java/java_exceptions.htm.", 
            "title": "Error Handling"
        }, 
        {
            "location": "/error_handling/#type-of-exceptions", 
            "text": "Checked Exception  A checked exception is an exception that occurs at the compile time, these are also called as compile time exceptions. These exceptions cannot simply be ignored at the time of compilation, the programmer should take care of (handle) these exceptions.  For example, if you use FileReader class in your program to read data from a file, if the file specified in its constructor doesn't exist, then a FileNotFoundException occurs, and the compiler prompts the programmer to handle the exception.  import java.io.File;\nimport java.io.FileReader;\n\npublic class FilenotFound_Demo {\n\n   public static void main(String args[]) {     \n      File file = new File( E://file.txt );\n      FileReader fr = new FileReader(file); \n   }\n}  If you try to compile the above program, you will get the following exceptions.  C:\\ javac FilenotFound_Demo.java\nFilenotFound_Demo.java:8: error: unreported exception FileNotFoundException; must be caught or declared to be thrown\n      FileReader fr = new FileReader(file);\n                      ^\n1 error  Note \u2212 Since the methods  read()  and  close()  of FileReader class throws IOException, you can observe that the compiler notifies to handle IOException, along with FileNotFoundException.  Unchecked exceptions  An unchecked exception is an exception that occurs at the time of execution. These are also called as  Runtime Exceptions . These include programming bugs, such as logic errors or improper use of an API. Runtime exceptions are ignored at the time of compilation.  For example, if you have declared an array of size 5 in your program, and trying to call the 6th element of the array then an  ArrayIndexOutOfBoundsExceptionexception  occurs.  public class Unchecked_Demo {\n\n   public static void main(String args[]) {\n      int num[] = {1, 2, 3, 4};\n      System.out.println(num[5]);\n   }\n}  If you compile and execute the above program, you will get the following exception.  Exception in thread  main  java.lang.ArrayIndexOutOfBoundsException: 5\n    at Exceptions.Unchecked_Demo.main(Unchecked_Demo.java:8)  Errors  These are not exceptions at all, but problems that arise beyond the control of the user or the programmer. Errors are typically ignored in your code because you can rarely do anything about an error. For example, if a stack overflow occurs, an error will arise. They are also ignored at the time of compilation.", 
            "title": "Type of exceptions"
        }, 
        {
            "location": "/error_handling/#exception-hierarchy", 
            "text": "All exception classes are subtypes of the java.lang.Exception class. The exception class is a subclass of the Throwable class. Other than the exception class there is another subclass called Error which is derived from the Throwable class.  Errors are abnormal conditions that happen in case of severe failures, these are not handled by the Java programs. Errors are generated to indicate errors generated by the runtime environment. Example: JVM is out of memory. Normally, programs cannot recover from errors.  The Exception class has two main subclasses: IOException class and RuntimeException Class.   Following is a list of most common checked and unchecked Java's Built-in Exceptions", 
            "title": "Exception Hierarchy"
        }, 
        {
            "location": "/error_handling/#exceptions-methods", 
            "text": "Following is the list of important methods available in the Throwable class.     1  public String getMessage() Returns a detailed message about the exception that has occurred. This message is initialized in the Throwable constructor.    2  public Throwable getCause() Returns the cause of the exception as represented by a Throwable object.    3  public String toString() Returns the name of the class concatenated with the result of getMessage().    4  public void printStackTrace() Prints the result of toString() along with the stack trace to System.err, the error output stream.    5  public StackTraceElement [] getStackTrace() Returns an array containing each element on the stack trace. The element at index 0 represents the top of the call stack, and the last element in the array represents the method at the bottom of the call stack.    6  public Throwable fillInStackTrace() Fills the stack trace of this Throwable object with the current stack trace, adding to any previous information in the stack trace.", 
            "title": "Exceptions Methods"
        }, 
        {
            "location": "/error_handling/#catching-exceptions", 
            "text": "A method catches an exception using a combination of the  try  and  catch  keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following  Syntax  try {\n   // Protected code\n}catch(ExceptionName e1) {\n   // Catch block\n}  The code which is prone to exceptions is placed in the try block. When an exception occurs, that exception occurred is handled by catch block associated with it. Every try block should be immediately followed either by a catch block or finally block.  A catch statement involves declaring the type of exception you are trying to catch. If an exception occurs in protected code, the catch block (or blocks) that follows the try is checked. If the type of exception that occurred is listed in a catch block, the exception is passed to the catch block much as an argument is passed into a method parameter.  Example  The following is an array declared with 2 elements. Then the code tries to access the 3rd element of the array which throws an exception.  // File Name : ExcepTest.java\nimport java.io.*;\n\npublic class ExcepTest {\n\n   public static void main(String args[]) {\n      try {\n         int a[] = new int[2];\n         System.out.println( Access element three :  + a[3]);\n      }catch(ArrayIndexOutOfBoundsException e) {\n         System.out.println( Exception thrown  :  + e);\n      }\n      System.out.println( Out of the block );\n   }\n}  This will produce the following result  Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3\nOut of the block", 
            "title": "Catching Exceptions"
        }, 
        {
            "location": "/error_handling/#multiple-catch-blocks", 
            "text": "A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following  try {\n   // Protected code\n}catch(ExceptionType1 e1) {\n   // Catch block\n}catch(ExceptionType2 e2) {\n   // Catch block\n}catch(ExceptionType3 e3) {\n   // Catch block\n}  The previous statements demonstrate three catch blocks, but you can have any number of them after a single try. If an exception occurs in the protected code, the exception is thrown to the first catch block in the list. If the data type of the exception thrown matches ExceptionType1, it gets caught there. If not, the exception passes down to the second catch statement. This continues until the exception either is caught or falls through all catches, in which case the current method stops execution and the exception is thrown down to the previous method on the call stack.  Example  Here is code segment showing how to use multiple try/catch statements.  try {\n   file = new FileInputStream(fileName);\n   x = (byte) file.read();\n}catch(IOException i) {\n   i.printStackTrace();\n   return -1;\n}catch(FileNotFoundException f) // Not valid! {\n   f.printStackTrace();\n   return -1;\n}", 
            "title": "Multiple Catch Blocks"
        }, 
        {
            "location": "/error_handling/#catching-multiple-type-of-exceptions", 
            "text": "Since Java 7, you can handle more than one exception using a single catch block, this feature simplifies the code. Here is how you would do it  catch (IOException|FileNotFoundException ex) {\n   logger.log(ex);\n   throw ex;", 
            "title": "Catching Multiple Type of Exceptions"
        }, 
        {
            "location": "/error_handling/#the-throwsthrow-keywords", 
            "text": "If a method does not handle a checked exception, the method must declare it using the throws keyword. The throws keyword appears at the end of a method's signature.  You can throw an exception, either a newly instantiated one or an exception that you just caught, by using the throw keyword.  Try to understand the difference between throws and throw keywords, throws is used to postpone the handling of a checked exception and throw is used to invoke an exception explicitly.  The following method declares that it throws a RemoteException   import java.io.*;\npublic class className {\n\n   public void deposit(double amount) throws RemoteException {\n      // Method implementation\n      throw new RemoteException();\n   }\n   // Remainder of class definition\n}  A method can declare that it throws more than one exception, in which case the exceptions are declared in a list separated by commas. For example, the following method declares that it throws a RemoteException and an InsufficientFundsException  import java.io.*;\npublic class className {\n\n   public void withdraw(double amount) throws RemoteException, \n      InsufficientFundsException {\n      // Method implementation\n   }\n   // Remainder of class definition\n}", 
            "title": "The Throws/Throw Keywords"
        }, 
        {
            "location": "/error_handling/#the-finally-block", 
            "text": "The finally block follows a try block or a catch block. A finally block of code always executes, irrespective of occurrence of an Exception.  Using a finally block allows you to run any cleanup-type statements that you want to execute, no matter what happens in the protected code.  A finally block appears at the end of the catch blocks and has the following syntax  Syntax  try {\n   // Protected code\n}catch(ExceptionType1 e1) {\n   // Catch block\n}catch(ExceptionType2 e2) {\n   // Catch block\n}catch(ExceptionType3 e3) {\n   // Catch block\n}finally {\n   // The finally block always executes.\n}  Example  public class ExcepTest {\n\n   public static void main(String args[]) {\n      int a[] = new int[2];\n      try {\n         System.out.println( Access element three :  + a[3]);\n      }catch(ArrayIndexOutOfBoundsException e) {\n         System.out.println( Exception thrown  :  + e);\n      }finally {\n         a[0] = 6;\n         System.out.println( First element value:   + a[0]);\n         System.out.println( The finally statement is executed );\n      }\n   }\n}  This will produce the following result   Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3\nFirst element value: 6\nThe finally statement is executed  Note the following   A catch clause cannot exist without a try statement.  It is not compulsory to have finally clauses whenever a try/catch block is present.  The try block cannot be present without either catch clause or finally clause.  Any code cannot be present in between the try, catch, finally blocks.", 
            "title": "The Finally Block"
        }, 
        {
            "location": "/error_handling/#the-try-with-resources", 
            "text": "Generally, when we use any resources like streams, connections, etc. we have to close them explicitly using finally block. In the following program, we are reading data from a file using FileReader and we are closing it using finally block.  import java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class ReadData_Demo {\n\n   public static void main(String args[]) {\n      FileReader fr = null;     \n      try {\n         File file = new File( file.txt );\n         fr = new FileReader(file); char [] a = new char[50];\n         fr.read(a);   // reads the content to the array\n         for(char c : a)\n         System.out.print(c);   // prints the characters one by one\n      }catch(IOException e) {\n         e.printStackTrace();\n      }finally {\n         try {\n            fr.close();\n         }catch(IOException ex) {       \n            ex.printStackTrace();\n         }\n      }\n   }\n}  try-with-resources, also referred as automatic resource management, is a new exception handling mechanism that was introduced in Java 7, which automatically closes the resources used within the try catch block.  To use this statement, you simply need to declare the required resources within the parenthesis, and the created resource will be closed automatically at the end of the block. Following is the syntax of try-with-resources statement.  Syntax  try(FileReader fr = new FileReader( file path )) {\n   // use the resource\n   }catch() {\n      // body of catch \n   }\n}  Following is the program that reads the data in a file using try-with-resources statement.  Example  import java.io.FileReader;\nimport java.io.IOException;\n\npublic class Try_withDemo {\n\n   public static void main(String args[]) {\n      try(FileReader fr = new FileReader( E://file.txt )) {\n         char [] a = new char[50];\n         fr.read(a);   // reads the contentto the array\n         for(char c : a)\n         System.out.print(c);   // prints the characters one by one\n      }catch(IOException e) {\n         e.printStackTrace();\n      }\n   }\n}  Following points are to be kept in mind while working with try-with-resources statement.   To use a class with try-with-resources statement it should implement AutoCloseable interface and the close() method of it gets invoked automatically at runtime.  You can declare more than one class in try-with-resources statement.  While you declare multiple classes in the try block of try-with-resources statement these classes are closed in reverse order.  Except the declaration of resources within the parenthesis everything is the same as normal try/catch block of a try block.  The resource declared in try gets instantiated just before the start of the try-block.  The resource declared at the try block is implicitly declared as final.", 
            "title": "The try-with-resources"
        }, 
        {
            "location": "/error_handling/#user-defined-exceptions", 
            "text": "You can create your own exceptions in Java. Keep the following points in mind when writing your own exception classes \u2212   All exceptions must be a child of Throwable.  If you want to write a checked exception that is automatically enforced by the Handle or Declare Rule, you need to extend the Exception class.  If you want to write a runtime exception, you need to extend the RuntimeException class.   We can define our own Exception class as below  class MyException extends Exception {\n}  You just need to extend the predefined Exception class to create your own Exception. These are considered to be checked exceptions. The following InsufficientFundsException class is a user-defined exception that extends the Exception class, making it a checked exception. An exception class is like any other class, containing useful fields and methods.  Example  // File Name InsufficientFundsException.java\nimport java.io.*;\n\npublic class InsufficientFundsException extends Exception {\n   private double amount;\n\n   public InsufficientFundsException(double amount) {\n      this.amount = amount;\n   }\n\n   public double getAmount() {\n      return amount;\n   }\n}  To demonstrate using our user-defined exception, the following CheckingAccount class contains a withdraw() method that throws an InsufficientFundsException.  // File Name CheckingAccount.java\nimport java.io.*;\n\npublic class CheckingAccount {\n   private double balance;\n   private int number;\n\n   public CheckingAccount(int number) {\n      this.number = number;\n   }\n\n   public void deposit(double amount) {\n      balance += amount;\n   }\n\n   public void withdraw(double amount) throws InsufficientFundsException {\n      if(amount  = balance) {\n         balance -= amount;\n      }else {\n         double needs = amount - balance;\n         throw new InsufficientFundsException(needs);\n      }\n   }\n\n   public double getBalance() {\n      return balance;\n   }\n\n   public int getNumber() {\n      return number;\n   }\n}  The following BankDemo program demonstrates invoking the deposit() and withdraw() methods of CheckingAccount.  // File Name BankDemo.java\npublic class BankDemo {\n\n   public static void main(String [] args) {\n      CheckingAccount c = new CheckingAccount(101);\n      System.out.println( Depositing $500... );\n      c.deposit(500.00);\n\n      try {\n         System.out.println( \\nWithdrawing $100... );\n         c.withdraw(100.00);\n         System.out.println( \\nWithdrawing $600... );\n         c.withdraw(600.00);\n      }catch(InsufficientFundsException e) {\n         System.out.println( Sorry, but you are short $  + e.getAmount());\n         e.printStackTrace();\n      }\n   }\n}  Compile all the above three files and run BankDemo. This will produce the following result   Output  Depositing $500...\n\nWithdrawing $100...\n\nWithdrawing $600...\nSorry, but you are short $200.0\nInsufficientFundsException\n         at CheckingAccount.withdraw(CheckingAccount.java:25)\n         at BankDemo.main(BankDemo.java:13)", 
            "title": "User-defined Exceptions"
        }, 
        {
            "location": "/error_handling/#common-exceptions", 
            "text": "In Java, it is possible to define two catergories of Exceptions and Errors.   JVM Exceptions \u2212 These are exceptions/errors that are exclusively or logically thrown by the JVM. Examples: NullPointerException, ArrayIndexOutOfBoundsException, ClassCastException.  Programmatic Exceptions \u2212 These exceptions are thrown explicitly by the application or the API programmers. Examples: IllegalArgumentException, IllegalStateException.", 
            "title": "Common Exceptions"
        }, 
        {
            "location": "/error_handling/#related-readings", 
            "text": "\"Java Exceptions\". 2016.  www.Tutorialspoint.Com . https://www.tutorialspoint.com/java/java_exceptions.htm.", 
            "title": "Related Readings"
        }, 
        {
            "location": "/ide/", 
            "text": "Java: IDE\n\n\nIntellIJ\n\n\n\u251c\u2500\u2500 1. Project Manager\n\u251c\u2500\u2500 2. Search \n Replace\n\u251c\u2500\u2500 3. Navigation\n\u251c\u2500\u2500 4. Formatting\n\u251c\u2500\u2500 5. Debugging\n\u251c\u2500\u2500 6. Build \n Release\n\u2514\u2500\u2500 7. Git Integration\n\n\n\n\n1. Project Manager\n\n\n1.1 Create New Project\n\n\n1.2 Import Maven Project\n\n\nhttps://www.jetbrains.com/help/idea/2016.1/importing-project-from-maven-model.html\n\n\n2. Search \n Replace\n\n\n\n\n\n\nGlobal Search\n\n\nShift Shift\n\n\n\n\n\n\n\n3. Navigation\n\n\n\n\n\n\nNext/Previous Error\n\n\nF2\n / \nShift + F2\n\n\n\n\n\n\n\n4. Formatting\n\n\n\n\n\n\nAuto Format\n\n\nCtrl + Alt + L", 
            "title": "IDE"
        }, 
        {
            "location": "/ide/#java-ide", 
            "text": "", 
            "title": "Java: IDE"
        }, 
        {
            "location": "/ide/#intellij", 
            "text": "\u251c\u2500\u2500 1. Project Manager\n\u251c\u2500\u2500 2. Search   Replace\n\u251c\u2500\u2500 3. Navigation\n\u251c\u2500\u2500 4. Formatting\n\u251c\u2500\u2500 5. Debugging\n\u251c\u2500\u2500 6. Build   Release\n\u2514\u2500\u2500 7. Git Integration", 
            "title": "IntellIJ"
        }, 
        {
            "location": "/ide/#1-project-manager", 
            "text": "1.1 Create New Project  1.2 Import Maven Project  https://www.jetbrains.com/help/idea/2016.1/importing-project-from-maven-model.html", 
            "title": "1. Project Manager"
        }, 
        {
            "location": "/ide/#2-search-replace", 
            "text": "Global Search  Shift Shift", 
            "title": "2. Search &amp; Replace"
        }, 
        {
            "location": "/ide/#3-navigation", 
            "text": "Next/Previous Error  F2  /  Shift + F2", 
            "title": "3. Navigation"
        }, 
        {
            "location": "/ide/#4-formatting", 
            "text": "Auto Format  Ctrl + Alt + L", 
            "title": "4. Formatting"
        }, 
        {
            "location": "/package_manager/", 
            "text": "Java: Package Manager\n\n\nGradle\n\n\n\n\nCreate your first project with gradle\n\n\nStep 1: Create new project folder\n\n\nmkdir gradle_sample\n\n\n\n\nStep 2: Make folder structure\n\n\ngradle init --type java-library\n\n\n\n\nStep 3: Import to IntelliJ\n\n\nOpen IntelliJ, click File \n New... \n Project From Existing Sources... \n\n\n\n\nPlugins\n\n\nApplication plugin\n\n\nUsages\n\n\n1.\n Using the application plugin\n\n\nAdd this line in \nbuild.gradle\n\n\napply plugin: 'application'\n\n\n\n\n2.\n  Configure the application main class\n\n\nmainClassName = \norg.gradle.sample.Main", 
            "title": "Package Manager"
        }, 
        {
            "location": "/package_manager/#java-package-manager", 
            "text": "", 
            "title": "Java: Package Manager"
        }, 
        {
            "location": "/package_manager/#gradle", 
            "text": "", 
            "title": "Gradle"
        }, 
        {
            "location": "/package_manager/#create-your-first-project-with-gradle", 
            "text": "Step 1: Create new project folder  mkdir gradle_sample  Step 2: Make folder structure  gradle init --type java-library  Step 3: Import to IntelliJ  Open IntelliJ, click File   New...   Project From Existing Sources...", 
            "title": "Create your first project with gradle"
        }, 
        {
            "location": "/package_manager/#plugins", 
            "text": "", 
            "title": "Plugins"
        }, 
        {
            "location": "/package_manager/#application-plugin", 
            "text": "Usages  1.  Using the application plugin  Add this line in  build.gradle  apply plugin: 'application'  2.   Configure the application main class  mainClassName =  org.gradle.sample.Main", 
            "title": "Application plugin"
        }, 
        {
            "location": "/build_tool/", 
            "text": "Java: Build Tool\n\n\nApache Ant\n\n\n\n\nApache Ant is a Java library and command-line tool whose mission is to drive processes described in build files as targets and extension points dependent upon each other. The main known usage of Ant is the build of Java applications. Ant supplies a number of built-in tasks allowing to compile, assemble, test and run Java applications. Ant can also be used effectively to build non Java applications, for instance C or C++ applications. More generally, Ant can be used to pilot any type of process which can be described in terms of targets and tasks. \n1\n\n\nInstall Ant\n\n\nDownload and extract Apache Ant 1.9.6\n\n\nwget http://mirrors.viethosting.vn/apache//ant/binaries/apache-ant-1.9.6-bin.tar.gz\ntar -xzf apache-ant-1.9.6-bin.tar.gz\n\n\n\n\nSet path to ant folder\n\n\nBuild Ant through proxy\n\n\n\nRequirement: 1.9.5+\n\n\nAdd the following lines into \nbuild.xml\n\n\ntarget name=\nivy-init\n depends=\nivy-proxy, ivy-probe-antlib, ivy-init-antlib\n description=\n--\n initialise Ivy settings\n\n  \nivy:settings file=\n${ivy.dir}/ivysettings.xml\n /\n\n  \n/target\n\n \ntarget name=\nivy-proxy\n description=\n--\nProxy Ivy settings\n\n  \nproperty name=\nproxy.host\n value=\nproxy.com\n /\n\n  \nproperty name=\nproxy.port\n value=\n8080\n /\n\n  \nproperty name=\nproxy.user\n value=\nuser\n /\n\n  \nproperty name=\nproxy.password\n value=\npassword\n /\n\n  \nsetproxy\n    proxyhost=\n${proxy.host}\n\n    proxyport=\n${proxy.port}\n\n    proxyuser=\n${proxy.user}\n\n    proxypassword=\n${proxy.password}\n /\n\n \n/target\n\n\n\n\n\n\n\n\n\n\n\n\n\nApache Ant\u2122", 
            "title": "Build Tool"
        }, 
        {
            "location": "/build_tool/#java-build-tool", 
            "text": "", 
            "title": "Java: Build Tool"
        }, 
        {
            "location": "/build_tool/#apache-ant", 
            "text": "Apache Ant is a Java library and command-line tool whose mission is to drive processes described in build files as targets and extension points dependent upon each other. The main known usage of Ant is the build of Java applications. Ant supplies a number of built-in tasks allowing to compile, assemble, test and run Java applications. Ant can also be used effectively to build non Java applications, for instance C or C++ applications. More generally, Ant can be used to pilot any type of process which can be described in terms of targets and tasks.  1", 
            "title": "Apache Ant"
        }, 
        {
            "location": "/build_tool/#install-ant", 
            "text": "Download and extract Apache Ant 1.9.6  wget http://mirrors.viethosting.vn/apache//ant/binaries/apache-ant-1.9.6-bin.tar.gz\ntar -xzf apache-ant-1.9.6-bin.tar.gz  Set path to ant folder", 
            "title": "Install Ant"
        }, 
        {
            "location": "/production/", 
            "text": "Java: Production (Docker)\n\n\nProduction with \njava\n\n\nBase Image: [java]\n/java\n\n\nDocker Folder\n\n\nyour-app/\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bin\n\u2502   \u251c\u2500\u2500\u2500\u2500\u2500 your_app.sh\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 lib\n\u251c\u2500\u2500 Dockerfile\n\u2514\u2500\u2500 run.sh\n\n\n\n\nDockerfile\n\n\nFROM java:7\n\nCOPY run.sh run.sh\n\n\n\n\nrun.sh\n\n\ncd /app/bin\nchmod u+x your_app.sh\n./your_app.sh\n\n\n\n\nCompose\n\n\n service:\n  build: ./your_app\n  command: 'bash run.sh'", 
            "title": "Production"
        }, 
        {
            "location": "/production/#java-production-docker", 
            "text": "Production with  java  Base Image: [java] /java  Docker Folder  your-app/\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bin\n\u2502   \u251c\u2500\u2500\u2500\u2500\u2500 your_app.sh\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 lib\n\u251c\u2500\u2500 Dockerfile\n\u2514\u2500\u2500 run.sh  Dockerfile  FROM java:7\n\nCOPY run.sh run.sh  run.sh  cd /app/bin\nchmod u+x your_app.sh\n./your_app.sh  Compose   service:\n  build: ./your_app\n  command: 'bash run.sh'", 
            "title": "Java: Production (Docker)"
        }
    ]
}